var GlancerEngine = function (n) { "use strict"; function u(Pa, Oa = !1, wa = !1) { if (null === Pa) return 0; if (Number.isInteger(Pa)) return Pa; if ("string" != typeof Pa) throw new TypeError("Invalid hash value type"); Oa || (Pa = Pa.toLowerCase()); let Fa = 4294967295; for (let Na, Ba = 0; Ba < Pa.length && (Na = Pa.charCodeAt(Ba)); Ba++)if (255 < Na) throw new RangeError("Unicode chars are not permitted"); else Fa = Fa >>> 8 ^ Fe[255 & Fa ^ Na] >>> 0; return Fa = wa ? ~Fa << 0 : ~Fa >>> 0, Fa } function T(Pa, Oa = 0, wa = Pa.size - Oa) { if (!(Pa instanceof Blob)) throw new TypeError("Invalid binary object type"); if (Oa + wa > Pa.size) throw new RangeError("Chunk block is out of range"); const Fa = new FileReader; return new Promise((Na, Ba) => { Fa.onload = Ma => Na(Ma.target.result), Fa.onerror = Ma => Ba(Ma), Fa.readAsArrayBuffer(Pa.slice(Oa, Oa + wa)) }) } function E(Pa = 0, Oa, wa = 1) { if (!Array.isArray(Oa) || 2 > Oa.length) return 0; let Na, Ba, Fa = 0; for (; Fa < Oa.length && Oa[Fa + 1];) { if (Na = Oa[Fa] * wa, Ba = Oa[Fa + 1] * wa, Na >= Ba) return 0; if (Pa >= Na && Pa < Ba) return Fa; Fa++ } return Fa } function S(Pa, Oa, wa, Fa, Na, Ba, Ma = 0) { function ja(Ka) { let Ja = 16; return Ka &= -Ka, Ka && Ja-- , 255 & Ka && (Ja -= 8), 3855 & Ka && (Ja -= 4), 13107 & Ka && (Ja -= 2), 21845 & Ka && (Ja -= 1), Ja } if (!(Pa instanceof Uint16Array)) throw new TypeError("Invalid 16bpp source pixel array type"); if (Oa * wa != Pa.length) throw new RangeError("Invalid source array size"); let Ga, Xa, Ha, Va, ka, Wa, za, qa, Ya = new Uint8Array(Oa * wa * (0 < Ma ? 4 : 3)); Fa && (ka = 255 / (Fa >> (Ga = ja(Fa)))), Na && (Wa = 255 / (Na >> (Xa = ja(Na)))), Ba && (za = 255 / (Ba >> (Ha = ja(Ba)))), Ma && (qa = 255 / (Ma >> (Va = ja(Ma)))); for (let Za, Ka = 0, Ja = 0; Ka < Pa.length; Ka++)Za = Pa[Ka], Ya[Ja++] = ka * (Za & Fa) >> Ga, Ya[Ja++] = Wa * (Za & Na) >> Xa, Ya[Ja++] = za * (Za & Ba) >> Ha, 0 < Ma && (Ya[Ja++] = qa * (Za & Ma) >> Va); return Ya } function _(Pa) { let Oa = new ct; return Oa.load(Pa), Oa } function I(Pa) { let Oa = new Ft; return Oa.load(Pa), Oa } function A() { let Pa = new Bt(9); return Bt != Float32Array && (Pa[1] = 0, Pa[2] = 0, Pa[3] = 0, Pa[5] = 0, Pa[6] = 0, Pa[7] = 0), Pa[0] = 1, Pa[4] = 1, Pa[8] = 1, Pa } function R(Pa, Oa) { let wa = Oa[0], Fa = Oa[1], Na = Oa[2], Ba = Oa[3], Ma = Oa[4], ja = Oa[5], Ya = Oa[6], Ga = Oa[7], Xa = Oa[8], Ha = Oa[9], Va = Oa[10], ka = Oa[11], Wa = Oa[12], za = Oa[13], qa = Oa[14], Ka = Oa[15], Ja = wa * ja - Fa * Ma, Za = wa * Ya - Na * Ma, Qa = wa * Ga - Ba * Ma, $a = Fa * Ya - Na * ja, ei = Fa * Ga - Ba * ja, ti = Na * Ga - Ba * Ya, ri = Xa * za - Ha * Wa, ai = Xa * qa - Va * Wa, ii = Xa * Ka - ka * Wa, ni = Ha * qa - Va * za, si = Ha * Ka - ka * za, oi = Va * Ka - ka * qa, di = Ja * oi - Za * si + Qa * ni + $a * ii - ei * ai + ti * ri; return di ? (di = 1 / di, Pa[0] = (ja * oi - Ya * si + Ga * ni) * di, Pa[1] = (Ya * ii - Ma * oi - Ga * ai) * di, Pa[2] = (Ma * si - ja * ii + Ga * ri) * di, Pa[3] = (Na * si - Fa * oi - Ba * ni) * di, Pa[4] = (wa * oi - Na * ii + Ba * ai) * di, Pa[5] = (Fa * ii - wa * si - Ba * ri) * di, Pa[6] = (za * ti - qa * ei + Ka * $a) * di, Pa[7] = (qa * Qa - Wa * ti - Ka * Za) * di, Pa[8] = (Wa * ei - za * Qa + Ka * Ja) * di, Pa) : null } function D() { let Pa = new Bt(16); return Bt != Float32Array && (Pa[1] = 0, Pa[2] = 0, Pa[3] = 0, Pa[4] = 0, Pa[6] = 0, Pa[7] = 0, Pa[8] = 0, Pa[9] = 0, Pa[11] = 0, Pa[12] = 0, Pa[13] = 0, Pa[14] = 0), Pa[0] = 1, Pa[5] = 1, Pa[10] = 1, Pa[15] = 1, Pa } function C(Pa) { let Oa = new Bt(16); return Oa[0] = Pa[0], Oa[1] = Pa[1], Oa[2] = Pa[2], Oa[3] = Pa[3], Oa[4] = Pa[4], Oa[5] = Pa[5], Oa[6] = Pa[6], Oa[7] = Pa[7], Oa[8] = Pa[8], Oa[9] = Pa[9], Oa[10] = Pa[10], Oa[11] = Pa[11], Oa[12] = Pa[12], Oa[13] = Pa[13], Oa[14] = Pa[14], Oa[15] = Pa[15], Oa } function L(Pa) { return Pa[0] = 1, Pa[1] = 0, Pa[2] = 0, Pa[3] = 0, Pa[4] = 0, Pa[5] = 1, Pa[6] = 0, Pa[7] = 0, Pa[8] = 0, Pa[9] = 0, Pa[10] = 1, Pa[11] = 0, Pa[12] = 0, Pa[13] = 0, Pa[14] = 0, Pa[15] = 1, Pa } function U(Pa, Oa, wa) { let Fa = Oa[0], Na = Oa[1], Ba = Oa[2], Ma = Oa[3], ja = Oa[4], Ya = Oa[5], Ga = Oa[6], Xa = Oa[7], Ha = Oa[8], Va = Oa[9], ka = Oa[10], Wa = Oa[11], za = Oa[12], qa = Oa[13], Ka = Oa[14], Ja = Oa[15], Za = wa[0], Qa = wa[1], $a = wa[2], ei = wa[3]; return Pa[0] = Za * Fa + Qa * ja + $a * Ha + ei * za, Pa[1] = Za * Na + Qa * Ya + $a * Va + ei * qa, Pa[2] = Za * Ba + Qa * Ga + $a * ka + ei * Ka, Pa[3] = Za * Ma + Qa * Xa + $a * Wa + ei * Ja, Za = wa[4], Qa = wa[5], $a = wa[6], ei = wa[7], Pa[4] = Za * Fa + Qa * ja + $a * Ha + ei * za, Pa[5] = Za * Na + Qa * Ya + $a * Va + ei * qa, Pa[6] = Za * Ba + Qa * Ga + $a * ka + ei * Ka, Pa[7] = Za * Ma + Qa * Xa + $a * Wa + ei * Ja, Za = wa[8], Qa = wa[9], $a = wa[10], ei = wa[11], Pa[8] = Za * Fa + Qa * ja + $a * Ha + ei * za, Pa[9] = Za * Na + Qa * Ya + $a * Va + ei * qa, Pa[10] = Za * Ba + Qa * Ga + $a * ka + ei * Ka, Pa[11] = Za * Ma + Qa * Xa + $a * Wa + ei * Ja, Za = wa[12], Qa = wa[13], $a = wa[14], ei = wa[15], Pa[12] = Za * Fa + Qa * ja + $a * Ha + ei * za, Pa[13] = Za * Na + Qa * Ya + $a * Va + ei * qa, Pa[14] = Za * Ba + Qa * Ga + $a * ka + ei * Ka, Pa[15] = Za * Ma + Qa * Xa + $a * Wa + ei * Ja, Pa } function P(Pa, Oa, wa) { let Ma, ja, Ya, Ga, Xa, Ha, Va, ka, Wa, za, qa, Ka, Fa = wa[0], Na = wa[1], Ba = wa[2]; return Oa === Pa ? (Pa[12] = Oa[0] * Fa + Oa[4] * Na + Oa[8] * Ba + Oa[12], Pa[13] = Oa[1] * Fa + Oa[5] * Na + Oa[9] * Ba + Oa[13], Pa[14] = Oa[2] * Fa + Oa[6] * Na + Oa[10] * Ba + Oa[14], Pa[15] = Oa[3] * Fa + Oa[7] * Na + Oa[11] * Ba + Oa[15]) : (Ma = Oa[0], ja = Oa[1], Ya = Oa[2], Ga = Oa[3], Xa = Oa[4], Ha = Oa[5], Va = Oa[6], ka = Oa[7], Wa = Oa[8], za = Oa[9], qa = Oa[10], Ka = Oa[11], Pa[0] = Ma, Pa[1] = ja, Pa[2] = Ya, Pa[3] = Ga, Pa[4] = Xa, Pa[5] = Ha, Pa[6] = Va, Pa[7] = ka, Pa[8] = Wa, Pa[9] = za, Pa[10] = qa, Pa[11] = Ka, Pa[12] = Ma * Fa + Xa * Na + Wa * Ba + Oa[12], Pa[13] = ja * Fa + Ha * Na + za * Ba + Oa[13], Pa[14] = Ya * Fa + Va * Na + qa * Ba + Oa[14], Pa[15] = Ga * Fa + ka * Na + Ka * Ba + Oa[15]), Pa } function O(Pa, Oa) { return Pa[0] = 1, Pa[1] = 0, Pa[2] = 0, Pa[3] = 0, Pa[4] = 0, Pa[5] = 1, Pa[6] = 0, Pa[7] = 0, Pa[8] = 0, Pa[9] = 0, Pa[10] = 1, Pa[11] = 0, Pa[12] = Oa[0], Pa[13] = Oa[1], Pa[14] = Oa[2], Pa[15] = 1, Pa } function F(Pa, Oa, wa) { let Fa = Oa[0], Na = Oa[1], Ba = Oa[2], Ma = Oa[3], ja = Fa + Fa, Ya = Na + Na, Ga = Ba + Ba, Xa = Fa * ja, Ha = Fa * Ya, Va = Fa * Ga, ka = Na * Ya, Wa = Na * Ga, za = Ba * Ga, qa = Ma * ja, Ka = Ma * Ya, Ja = Ma * Ga; return Pa[0] = 1 - (ka + za), Pa[1] = Ha + Ja, Pa[2] = Va - Ka, Pa[3] = 0, Pa[4] = Ha - Ja, Pa[5] = 1 - (Xa + za), Pa[6] = Wa + qa, Pa[7] = 0, Pa[8] = Va + Ka, Pa[9] = Wa - qa, Pa[10] = 1 - (Xa + ka), Pa[11] = 0, Pa[12] = wa[0], Pa[13] = wa[1], Pa[14] = wa[2], Pa[15] = 1, Pa } function N(Pa, Oa) { return Pa[0] = Oa[12], Pa[1] = Oa[13], Pa[2] = Oa[14], Pa } function B(Pa, Oa) { let wa = Oa[0], Fa = Oa[1], Na = Oa[2], Ba = Oa[3], Ma = wa + wa, ja = Fa + Fa, Ya = Na + Na, Ga = wa * Ma, Xa = Fa * Ma, Ha = Fa * ja, Va = Na * Ma, ka = Na * ja, Wa = Na * Ya, za = Ba * Ma, qa = Ba * ja, Ka = Ba * Ya; return Pa[0] = 1 - Ha - Wa, Pa[1] = Xa + Ka, Pa[2] = Va - qa, Pa[3] = 0, Pa[4] = Xa - Ka, Pa[5] = 1 - Ga - Wa, Pa[6] = ka + za, Pa[7] = 0, Pa[8] = Va + qa, Pa[9] = ka - za, Pa[10] = 1 - Ga - Ha, Pa[11] = 0, Pa[12] = 0, Pa[13] = 0, Pa[14] = 0, Pa[15] = 1, Pa } function M(Pa, Oa, wa, Fa, Na) { let Ma, Ba = 1 / Math.tan(Oa / 2); return Pa[0] = Ba / wa, Pa[1] = 0, Pa[2] = 0, Pa[3] = 0, Pa[4] = 0, Pa[5] = Ba, Pa[6] = 0, Pa[7] = 0, Pa[8] = 0, Pa[9] = 0, Pa[11] = -1, Pa[12] = 0, Pa[13] = 0, Pa[15] = 0, null != Na && Na !== Infinity ? (Ma = 1 / (Fa - Na), Pa[10] = (Na + Fa) * Ma, Pa[14] = 2 * Na * Fa * Ma) : (Pa[10] = -1, Pa[14] = -2 * Fa), Pa } function Y() { let Pa = new Bt(3); return Bt != Float32Array && (Pa[0] = 0, Pa[1] = 0, Pa[2] = 0), Pa } function G(Pa) { let Oa = Pa[0], wa = Pa[1], Fa = Pa[2]; return Math.sqrt(Oa * Oa + wa * wa + Fa * Fa) } function X(Pa, Oa, wa) { let Fa = new Bt(3); return Fa[0] = Pa, Fa[1] = Oa, Fa[2] = wa, Fa } function H(Pa, Oa) { return Pa[0] = Oa[0], Pa[1] = Oa[1], Pa[2] = Oa[2], Pa } function V(Pa, Oa, wa) { return Pa[0] = Oa[0] + wa[0], Pa[1] = Oa[1] + wa[1], Pa[2] = Oa[2] + wa[2], Pa } function W(Pa, Oa, wa) { return Pa[0] = Oa[0] * wa, Pa[1] = Oa[1] * wa, Pa[2] = Oa[2] * wa, Pa } function K(Pa, Oa, wa, Fa) { return Pa[0] = Oa[0] + wa[0] * Fa, Pa[1] = Oa[1] + wa[1] * Fa, Pa[2] = Oa[2] + wa[2] * Fa, Pa } function J(Pa) { let Oa = Pa[0], wa = Pa[1], Fa = Pa[2]; return Oa * Oa + wa * wa + Fa * Fa } function Z(Pa, Oa) { let wa = Oa[0], Fa = Oa[1], Na = Oa[2], Ba = wa * wa + Fa * Fa + Na * Na; return 0 < Ba && (Ba = 1 / Math.sqrt(Ba)), Pa[0] = Oa[0] * Ba, Pa[1] = Oa[1] * Ba, Pa[2] = Oa[2] * Ba, Pa } function Q(Pa, Oa) { return Pa[0] * Oa[0] + Pa[1] * Oa[1] + Pa[2] * Oa[2] } function $(Pa, Oa, wa) { let Fa = Oa[0], Na = Oa[1], Ba = Oa[2], Ma = wa[0], ja = wa[1], Ya = wa[2]; return Pa[0] = Na * Ya - Ba * ja, Pa[1] = Ba * Ma - Fa * Ya, Pa[2] = Fa * ja - Na * Ma, Pa } function ee(Pa, Oa, wa) { let Fa = Oa[0], Na = Oa[1], Ba = Oa[2], Ma = wa[3] * Fa + wa[7] * Na + wa[11] * Ba + wa[15]; return Ma = Ma || 1, Pa[0] = (wa[0] * Fa + wa[4] * Na + wa[8] * Ba + wa[12]) / Ma, Pa[1] = (wa[1] * Fa + wa[5] * Na + wa[9] * Ba + wa[13]) / Ma, Pa[2] = (wa[2] * Fa + wa[6] * Na + wa[10] * Ba + wa[14]) / Ma, Pa } function te(Pa, Oa, wa) { let Fa = wa[0], Na = wa[1], Ba = wa[2], Ma = wa[3], ja = Oa[0], Ya = Oa[1], Ga = Oa[2], Xa = Na * Ga - Ba * Ya, Ha = Ba * ja - Fa * Ga, Va = Fa * Ya - Na * ja, ka = Na * Va - Ba * Ha, Wa = Ba * Xa - Fa * Va, za = Fa * Ha - Na * Xa, qa = 2 * Ma; return Xa *= qa, Ha *= qa, Va *= qa, ka *= 2, Wa *= 2, za *= 2, Pa[0] = ja + Xa + ka, Pa[1] = Ya + Ha + Wa, Pa[2] = Ga + Va + za, Pa } function re() { let Pa = new Bt(4); return Bt != Float32Array && (Pa[0] = 0, Pa[1] = 0, Pa[2] = 0, Pa[3] = 0), Pa } function ne() { let Pa = new Bt(4); return Bt != Float32Array && (Pa[0] = 0, Pa[1] = 0, Pa[2] = 0), Pa[3] = 1, Pa } function se(Pa, Oa, wa) { wa *= 0.5; let Fa = Math.sin(wa); return Pa[0] = Fa * Oa[0], Pa[1] = Fa * Oa[1], Pa[2] = Fa * Oa[2], Pa[3] = Math.cos(wa), Pa } function oe(Pa, Oa, wa) { wa *= 0.5; let Fa = Oa[0], Na = Oa[1], Ba = Oa[2], Ma = Oa[3], ja = Math.sin(wa), Ya = Math.cos(wa); return Pa[0] = Fa * Ya - Ba * ja, Pa[1] = Na * Ya + Ma * ja, Pa[2] = Ba * Ya + Fa * ja, Pa[3] = Ma * Ya - Na * ja, Pa } function de(Pa, Oa, wa, Fa) { let Va, ka, Wa, za, qa, Na = Oa[0], Ba = Oa[1], Ma = Oa[2], ja = Oa[3], Ya = wa[0], Ga = wa[1], Xa = wa[2], Ha = wa[3]; return ka = Na * Ya + Ba * Ga + Ma * Xa + ja * Ha, 0 > ka && (ka = -ka, Ya = -Ya, Ga = -Ga, Xa = -Xa, Ha = -Ha), 1 - ka > 1e-6 ? (Va = Math.acos(ka), Wa = Math.sin(Va), za = Math.sin((1 - Fa) * Va) / Wa, qa = Math.sin(Fa * Va) / Wa) : (za = 1 - Fa, qa = Fa), Pa[0] = za * Na + qa * Ya, Pa[1] = za * Ba + qa * Ga, Pa[2] = za * Ma + qa * Xa, Pa[3] = za * ja + qa * Ha, Pa } function le(Pa, Oa) { let wa = Oa[0], Fa = Oa[1], Na = Oa[2], Ba = Oa[3], Ma = wa * wa + Fa * Fa + Na * Na + Ba * Ba, ja = Ma ? 1 / Ma : 0; return Pa[0] = -wa * ja, Pa[1] = -Fa * ja, Pa[2] = -Na * ja, Pa[3] = Ba * ja, Pa } function ue(Pa, Oa) { let Fa, wa = Oa[0] + Oa[4] + Oa[8]; if (0 < wa) Fa = Math.sqrt(wa + 1), Pa[3] = 0.5 * Fa, Fa = 0.5 / Fa, Pa[0] = (Oa[5] - Oa[7]) * Fa, Pa[1] = (Oa[6] - Oa[2]) * Fa, Pa[2] = (Oa[1] - Oa[3]) * Fa; else { let Na = 0; Oa[4] > Oa[0] && (Na = 1), Oa[8] > Oa[3 * Na + Na] && (Na = 2); let Ba = (Na + 1) % 3, Ma = (Na + 2) % 3; Fa = Math.sqrt(Oa[3 * Na + Na] - Oa[3 * Ba + Ba] - Oa[3 * Ma + Ma] + 1), Pa[Na] = 0.5 * Fa, Fa = 0.5 / Fa, Pa[3] = (Oa[3 * Ba + Ma] - Oa[3 * Ma + Ba]) * Fa, Pa[Ba] = (Oa[3 * Ba + Na] + Oa[3 * Na + Ba]) * Fa, Pa[Ma] = (Oa[3 * Ma + Na] + Oa[3 * Na + Ma]) * Fa } return Pa } function me() { let Pa = new Bt(2); return Bt != Float32Array && (Pa[0] = 0, Pa[1] = 0), Pa } function ce(Pa, Oa, wa) { return Pa * (1 - wa) + Oa * wa } function fe(Pa, Oa, wa) { return Pa[0] = wa[0], Pa[1] = wa[3], Pa[2] = wa[6], Pa[3] = 0, Pa[4] = wa[1], Pa[5] = wa[4], Pa[6] = wa[7], Pa[7] = 0, Pa[8] = wa[2], Pa[9] = wa[5], Pa[10] = wa[8], Pa[11] = 0, Pa[12] = Oa[0], Pa[13] = Oa[1], Pa[14] = Oa[2], Pa[15] = 1, Pa } function ge(Pa, Oa, wa) { let Fa = 0.5 * Math.PI / 180; Oa *= Fa, wa *= Fa; let Na = Math.sin(Oa), Ba = Math.cos(Oa), Ma = Math.sin(wa), ja = Math.cos(wa); return Pa[0] = Na * ja, Pa[1] = Ba * Ma, Pa[2] = Na * Ma, Pa[3] = Ba * ja, Pa } function* pe(Pa, Oa = !1) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object type"); if (!Pa.hasChild) throw new TypeError("Constraints entry is empty"); let [wa] = Pa.find("cons"); if (!wa) return !1; let [Fa, Na, Ba, Ma, ja, Ya] = wa.find("fix", "rev", "pris", "cyl", "sphere", "loose"); Fa && (yield* he(Fa.data, or, 176)), Na && (yield* he(Na.data, lr, 208)), Ba && (yield* he(Ba.data, ur, 208)), Ma && (yield* he(Ma.data, mr, 204)), ja && (yield* he(ja.data, cr, 212)), Ya && (yield* he(Ya.data, dr, 176)) } function* he(Pa, Oa, wa) { for (let Fa, Na, Ba; Pa.byteLength >= wa;)Na = Pa.readString(64), Ba = Pa.readString(64), (Fa = new Oa).load(Pa), yield [Ba, Na, Fa] } function* Te(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object type"); if (!Pa.hasChild) return !1; let [Oa] = Pa.find("hardpoints"); if (!Oa) return !1; let [wa, Fa, Na] = Oa.find("fixed", "revolute", "prismatic"); wa && (yield* Ee(wa, Sr)), Fa && (yield* Ee(Fa, _r)), Na && (yield* Ee(Na, yr)) } function* Ee(Pa, Oa) { for (let [wa, Fa] of Pa) { let Na = new Oa; Na.load(Fa, wa), yield [Fa.name, Na] } } function* ve(Pa, Oa, wa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid compound UTF entry object type"); if (!(Oa instanceof ke)) throw new TypeError("Invalid fragments UTF entry object type"); if ("function" != typeof wa) throw new TypeError("Invalid compound part constructor type"); for (let [Fa, Na] of Pa) if (("root" == Fa || Fa.startsWith("part_")) && Na.hasChild) { let [Xa, Ha, Va] = Na.find("object name", "index", "file name"); if (!Xa) throw new RangeError("Compound part (" + Fa + ") is missing object name"); if (!Va) throw new RangeError("Compound part (" + Fa + ") is missing fragment file name"); Xa = Xa.data.readString(), Va = Va.data.readString(), Ha && (Ha = Ha.data.readInteger()); let [ka] = Oa.find(Va); if (!ka) throw new RangeError("Referenced fragment entry (" + Va + ") for part (" + Xa + ") is missing"); if (!ka.hasChild) throw new RangeError("Fragment entry is empty"); let Wa = new wa; "function" == typeof Wa.load && Wa.load(ka), yield [Xa, Ha, ka, Wa] } } function be(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid texture entry object type"); let Fa, [Oa, wa] = Pa.find("mips", "cube"); if (Oa) Fa = nt.fromDDS(new it(Oa.data)); else if (wa) console.warn("Cubemaps not implemented"); else { let Na, Ba = []; for (let [Ma, ja] of Pa) ja.hasData && (Na = Kr.exec(Ma)) && (Ba[parseInt(Na[1])] = new at(ja.data)); Ba.length && (Fa = nt.fromTarga(...Ba)) } return Fa } function xe(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid material entry object"); if (!Pa.hasChild) return !1; let Fa, Na, Ba, Ma, Oa = !1, wa = !1; for (const [ja, Ya] of ea) !Na && ja.test(Pa.tag) && (Na = Ya); if (!Na) { if ([Ba] = Pa.find("type"), !Ba) return !1; switch (Ma = Ba.data.readString(), ta.has(Ma) && (Ma = ta.get(Ma)), Ma) { case "DcDtTwo": case "DcDtEcTwo": case "DcDtOcOtTwo": case "DcDtEcOcOtTwo": Oa = !0; case "EcEt": case "DcDt": case "DcDtEc": case "DcDtEt": case "DcDtEcEt": case "DcDtOcOt": case "DcDtEcOcOt": Na = ot; break; case "BtDetailMapMaterial": Na = dt; break; case "NebulaTwo": Oa = !0; case "Nebula": Na = lt, wa = !0; break; case "NomadMaterial": Na = ut, wa = !0; break; case "NullMaterial": default: Na = st; } } return !!Na && (Fa = new Na, Ma && (Fa.type = Ma), Oa && (Fa.twoSided = !0), wa && (Fa.alpha = !0), Fa.load(Pa), Fa) } function Se(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid mesh entry object"); let [Oa] = Pa.find("vmeshdata"); if (!Oa) return !1; let wa = new Dt; return wa.load(Oa.data), wa } function _e(Pa) { if (!(Pa instanceof We)) throw new TypeError("Invalid rigid model reader type"); let Fa, [Oa, wa] = Pa.root.find("cmpnd", "sphere"); return Oa ? (Fa = new Gr).load(Oa, Pa.root) : wa ? (Fa = new Hr).load(wa) : (Fa = new Xr).load(Pa.root), Fa } function ye(Pa, Oa, wa, Fa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object type"); if (!Pa.hasChild) return !1; if ("function" != typeof Oa) return !1; for (let [Na, Ba] of Pa) if (Ba.hasChild) { let qa = u(Na); if (!(wa && wa.has(qa) && (!Fa || wa.get(qa) != Fa))) { let Ka = Oa(Ba); Ka && wa.set(qa, Ka) } } return !0 } function Ie(Pa) { let Oa = 31 & Pa >> 11, wa = 63 & Pa >> 5, Fa = 31 & Pa; return Oa = Oa << 3 | Oa >> 2, wa = wa << 2 | wa >> 4, Fa = Fa << 3 | Fa >> 2, [Oa, wa, Fa] } function Ae(Pa, Oa, wa) { const Fa = new Uint8Array(16), Na = new Uint8Array(16); let Ba = Oa[wa + 1] << 8 | Oa[wa + 0], Ma = Oa[wa + 3] << 8 | Oa[wa + 2], ja = 0, Ya = 0, Ga = Ba <= Ma, Xa = Pa.byteLength / 16;[Fa[0], Fa[1], Fa[2]] = Ie(Ba), [Fa[4], Fa[5], Fa[6]] = Ie(Ma), Fa[3] = Fa[7] = 255; for (let Ha = 0; 3 > Ha; Ha++)ja = Fa[Ha], Ya = Fa[4 + Ha], Fa[Ha + 8] = Ga ? (ja + Ya) / 2 : (2 * ja + Ya) / 3, Fa[Ha + 12] = Ga ? 0 : (ja + 2 * Ya) / 3; Fa[11] = 255, Fa[15] = Ga ? 0 : 255; for (let Ha = 0, Va = 0; 4 > Ha; Ha++)Va = Oa[wa + Ha + 4], Na[4 * Ha + 0] = 3 & Va, Na[4 * Ha + 1] = 3 & Va >> 2, Na[4 * Ha + 2] = 3 & Va >> 4, Na[4 * Ha + 3] = 3 & Va >> 6; for (let Ha = 0, Va = 0, ka = 0; Ha < Na.length; Ha++)ka = 4 * Na[Ha], Pa[Va++] = Fa[ka + 0], Pa[Va++] = Fa[ka + 1], Pa[Va++] = Fa[ka + 2], 4 == Xa && (Pa[Va++] = Fa[ka + 3]); return !0 } function Re(Pa, Oa, wa) { for (let Fa = 0, Na = 0, Ba = 0, Ma = 0; 8 > Fa; Fa++)Na = Oa[wa + Fa], Ba = 15 & Na, Ma = 240 & Na, Pa[8 * Fa + 3] = Ba | Ba << 4, Pa[8 * Fa + 7] = Ma | Ma >> 4; return !0 } function De(Pa, Oa, wa) { const Fa = new Uint8Array(8), Na = new Uint8Array(16), Ba = Oa[wa + 0], Ma = Oa[wa + 1]; if (Fa[0] = Ba, Fa[1] = Ma, Fa[6] = 0, Fa[7] = 255, Ba > Ma) for (let ja = 1; 7 > ja; ja++)Fa[ja + 1] = ((7 - ja) * Ba + ja * Ma) / 7; else for (let ja = 1; 5 > ja; ja++)Fa[ja + 1] = ((5 - ja) * Ba + ja * Ma) / 5; wa += 2; for (let ja = 0, Ya = 0, Ga = 0; 2 > ja; ja++) { for (let Xa = 0; 3 > Xa; Xa++)Ga |= Oa[wa++] << 8 * Xa; for (let Xa = 0; 8 > Xa; Xa++)Na[Ya++] = 7 & Ga >> 3 * Xa; Ga = 0 } for (let ja = 0; ja < Na.length; ja++)Pa[4 * ja + 3] = Fa[Na[ja]]; return !0 } function Ce(Pa, Oa, wa, Fa, Na) { if (!(Pa instanceof Uint8Array || Pa instanceof Uint8ClampedArray)) throw new TypeError("Invalid source image type"); if (0 != Oa % 4) throw new RangeError("Invalid image width"); if (0 != wa % 4) throw new RangeError("Invalid image height"); const Ba = Na ? 4 : 3, Ma = Oa * Ba, ja = Fa == nt.TYPE_S3TC_DXT1 ? 8 : 16, Ya = 4 * Ba, Ga = new Uint8Array(16 * Ba), Xa = new Uint8Array(Oa * wa * Ba); for (let Ha = 0, Va = 0; Ha < Pa.byteLength; Ha += ja) { switch (Fa) { case nt.TYPE_S3TC_DXT1: Ae(Ga, Pa, Ha); break; case nt.TYPE_S3TC_DXT3: Ae(Ga, Pa, Ha + 8), Na && Re(Ga, Pa, Ha); break; case nt.TYPE_S3TC_DXT5: Ae(Ga, Pa, Ha + 8), Na && De(Ga, Pa, Ha); break; default: throw new TypeError("Invalid DXT compression type"); }for (let ka = 0, Wa = Va; ka < Ga.byteLength; ka += Ya)Xa.set(Ga.subarray(ka, ka + Ya), Wa), Wa += Ma; 0 == (Va += Ya) % Ma && (Va += 3 * Ma) } return Xa } function Le(Pa, Oa, wa) { function Fa(ja, Ya) { const Ga = Pa.createShader(Ya); if (Pa.shaderSource(Ga, ja), Pa.compileShader(Ga), !Pa.getShaderParameter(Ga, Pa.COMPILE_STATUS) && !Pa.isContextLost()) throw new Error("Error compiling shader:\n" + Pa.getShaderInfoLog(Ga)); return Ga } if (!(Pa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); const Na = Fa(Oa, Pa.VERTEX_SHADER), Ba = Fa(wa, Pa.FRAGMENT_SHADER), Ma = Pa.createProgram(); if (Pa.attachShader(Ma, Na), Pa.attachShader(Ma, Ba), Pa.linkProgram(Ma), !Pa.getProgramParameter(Ma, Pa.LINK_STATUS) && !Pa.isContextLost()) throw new Error("Error linking program:\n" + Pa.getProgramInfoLog(Ma)); return Ma } function Ue(Pa, Oa, wa) { if (!(Pa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!(Oa instanceof nt)) throw new TypeError("Invalid texture object"); if (!Oa.mipmaps.length) throw new RangeError("Texture object has no mipmaps"); let Fa, Na, Ba; if (!Fa) switch (Oa.type) { case nt.TYPE_RGB16_565: Fa = Pa.RGB, Na = Pa.UNSIGNED_SHORT_5_6_5; break; case nt.TYPE_RGBA16_4444: Fa = Pa.RGBA, Na = Pa.UNSIGNED_SHORT_4_4_4_4; break; case nt.TYPE_RGBA16_5551: Fa = Pa.RGBA, Na = Pa.UNSIGNED_SHORT_5_5_5_1; break; case nt.TYPE_RGB24_888: Fa = Pa.RGB, Na = Pa.UNSIGNED_BYTE; break; case nt.TYPE_RGBA32_8888: Fa = Pa.RGBA, Na = Pa.UNSIGNED_BYTE; break; case nt.TYPE_S3TC_DXT1: case nt.TYPE_S3TC_DXT3: case nt.TYPE_S3TC_DXT5: Fa = wa ? Pa.RGBA : Pa.RGB, Na = Pa.UNSIGNED_BYTE, Ba = Ce; break; default: throw new TypeError("Unknown texture type"); }const Ma = Pa.createTexture(); Pa.bindTexture(Pa.TEXTURE_2D, Ma), Pa.texParameteri(Pa.TEXTURE_2D, Pa.TEXTURE_MIN_FILTER, Pa.LINEAR_MIPMAP_LINEAR), Pa.texParameteri(Pa.TEXTURE_2D, Pa.TEXTURE_MAG_FILTER, Pa.LINEAR); for (let [ja, Ya, Ga, Xa] of Oa.getMipmaps()) { if (0 < ja) break; "function" == typeof Ba && (Xa = Ba(Xa, Ya, Ga, Oa.type, wa)), Pa.texImage2D(Pa.TEXTURE_2D, ja, Fa, Ya, Ga, 0, Fa, Na, Xa) } return Pa.generateMipmap(Pa.TEXTURE_2D), Pa.bindTexture(Pa.TEXTURE_2D, null), Ma } function Pe(Pa, Oa = 4, wa = 4) { if (!(Pa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!Number.isInteger(Oa) || 0 >= Oa) throw new RangeError("Invalid texture width"); if (!Number.isInteger(wa) || 0 >= wa) throw new RangeError("Invalid texture height"); const Fa = Pa.createTexture(), Na = new Uint8Array(3 * (Oa * wa)); return window.crypto.getRandomValues(Na), Pa.bindTexture(Pa.TEXTURE_2D, Fa), Pa.texParameteri(Pa.TEXTURE_2D, Pa.TEXTURE_MIN_FILTER, Pa.NEAREST), Pa.texParameteri(Pa.TEXTURE_2D, Pa.TEXTURE_MAG_FILTER, Pa.NEAREST), Pa.texImage2D(Pa.TEXTURE_2D, 0, Pa.RGB, Oa, wa, 0, Pa.RGB, Pa.UNSIGNED_BYTE, Na), Pa.bindTexture(Pa.TEXTURE_2D, null), Fa } function Oe(Pa, Oa, wa) { if (!(Pa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!Oa) throw new TypeError("Missing vertex array object extension"); if (!(wa instanceof Dt)) throw new TypeError("Invalid mesh data object"); if (!wa.groups.length) throw new RangeError("Mesh data has no groups"); if (!wa.indices.length) throw new RangeError("Mesh data has no indices"); if (!wa.vertices.length) throw new RangeError("Mesh data has no vertices"); const Fa = Oa.createVertexArrayOES(), Na = Pa.createBuffer(), Ba = Pa.createBuffer(); Oa.bindVertexArrayOES(Fa), Pa.bindBuffer(Pa.ELEMENT_ARRAY_BUFFER, Na), Pa.bufferData(Pa.ELEMENT_ARRAY_BUFFER, wa.indices, Pa.STATIC_DRAW), Pa.bindBuffer(Pa.ARRAY_BUFFER, Ba), Pa.bufferData(Pa.ARRAY_BUFFER, wa.vertices, Pa.STATIC_DRAW), 0 <= wa.positionOffset && (Pa.vertexAttribPointer(0, 3, Pa.FLOAT, !1, wa.vertexLength, wa.positionOffset), Pa.enableVertexAttribArray(0)), 0 <= wa.normalOffset && (Pa.vertexAttribPointer(1, 3, Pa.FLOAT, !1, wa.vertexLength, wa.normalOffset), Pa.enableVertexAttribArray(1)), 0 <= wa.diffuseOffset && (Pa.vertexAttribPointer(2, 4, Pa.UNSIGNED_BYTE, !0, wa.vertexLength, wa.diffuseOffset), Pa.enableVertexAttribArray(2)); for (let Ma = 0; Ma < wa.mapCount; Ma++)Pa.vertexAttribPointer(3 + Ma, 2, Pa.FLOAT, !1, wa.vertexLength, wa.getMapOffset(Ma)), Pa.enableVertexAttribArray(3 + Ma); return Oa.bindVertexArrayOES(null), Fa } function we(Pa) { this.elapsed += this.delta = Pa - this.previous, this.previous = Pa, this.status = Ua.STATUS_INPUT, this.input && this.input.update(this.delta), this.status = Ua.STATUS_SCENE, this.scene && this.scene.update(this.delta), this.status = Ua.STATUS_RENDER, this.render && this.render.drawScene(this.delta, this.scene, this.input, this.resources), this.ticks++ , this.nextFrame = Da(this.loop, this.render.canvas) } const Fe = new Uint32Array([0, 151466134, 302932268, 453595578, 4285383705, 4134204559, 3982730549, 3831797155, 4275800114, 4158437540, 3973441822, 3855800712, 28724267, 145849533, 330837255, 448732561, 4256632932, 4105183474, 4021907784, 3871228382, 47895677, 199091435, 282375505, 433292743, 57448534, 174827712, 291699066, 409324012, 4227947599, 4110839001, 3993976163, 3876064757, 4218298568, 4066971742, 3915399652, 3764875634, 67364049, 218420295, 369985021, 520795499, 95791354, 213031020, 398182870, 515701056, 4208487651, 4091501685, 3906342351, 3788586329, 114897068, 266207290, 349655424, 500195606, 4189385909, 4038312995, 3954873753, 3804079375, 4160927902, 4043671560, 3926710706, 3809208612, 124746887, 241716241, 358686123, 476458301, 4141629840, 4292571398, 3838976188, 3990163498, 162629001, 11973919, 465560741, 314102835, 134728098, 16841012, 436840590, 319723544, 4150922683, 4268571949, 3848563863, 3965934593, 191582708, 40657250, 426062040, 274858062, 4094072301, 4244743547, 3859346625, 4010787927, 4122008006, 4239911248, 3888036074, 4005136508, 182263263, 64630089, 416513267, 299125861, 229794136, 78991822, 532414580, 381366498, 4074743105, 4225275351, 3771843693, 3923178747, 4083804522, 4201568764, 3781658694, 3898652880, 201600371, 84090341, 503991391, 386759881, 4026888508, 4177674666, 3792375824, 3943440518, 258520357, 107972019, 493278217, 341959839, 249493774, 131713432, 483432482, 366454964, 4055055639, 4172549505, 3820837947, 3938086061, 3988292384, 3837768630, 4290175500, 4138848922, 315967289, 466778031, 14362133, 165418627, 325258002, 442776452, 23947838, 141187752, 3960393483, 3842637725, 4261457447, 4144471729, 269456196, 419996626, 33682024, 184992510, 4016199517, 3865405387, 4251727473, 4100654823, 4006878070, 3889376224, 4242176602, 4124920524, 297394031, 415166457, 62373443, 179343061, 383165416, 533828478, 81314500, 232780370, 3921373169, 3770439527, 4222944989, 4071765579, 3893177306, 3775535948, 4194519798, 4077156960, 392228803, 510123861, 91131631, 208256633, 3949048716, 3798369050, 4184855200, 4033405494, 336361365, 487278339, 100800185, 251995695, 364526526, 482151208, 129260178, 246639108, 3940024231, 3822112561, 4175011467, 4057902621, 459588272, 308539942, 157983644, 7181066, 3825796777, 3977131583, 4127680389, 4278212371, 3854518914, 3971512852, 4155583406, 4273347384, 450006683, 332774925, 148697015, 31186721, 3872641748, 4023706178, 4108170232, 4258956142, 431888077, 280569435, 196114401, 45565815, 403200742, 286222960, 168180682, 50400092, 3882196735, 3999444585, 4117495763, 4234989381, 3758809720, 3909997294, 4060382036, 4211323842, 526853729, 375396087, 225003341, 74348507, 517040714, 399923932, 215944038, 98057200, 3787238995, 3904609989, 4088582015, 4206231529, 498987548, 347783818, 263426864, 112501670, 3805296133, 3956737683, 4041103145, 4191774655, 3815143982, 3932244664, 4050131714, 4168035220, 470531639, 353144481, 235265819, 117632909]), Ne = "complete"; class Be { constructor(Pa = location.origin, Oa = document.createElement("progress"), wa = document.createElement("label")) { this.basePath = Pa, this.status = Be.STATUS_IDLE, this.queue = [], Oa instanceof HTMLProgressElement && (this.progress = Oa), wa instanceof HTMLElement && (this.message = wa) } get queuedCount() { return this.queue.length } get completedCount() { return this.queue.reduce((Pa, Oa) => Oa.readyState == XMLHttpRequest.DONE ? Pa + 1 : Pa, 0) } get pendingCount() { return this.queue.reduce((Pa, Oa) => Oa.readyState == XMLHttpRequest.OPENED ? Pa + 1 : Pa, 0) } get loadingCount() { return this.queue.reduce((Pa, Oa) => Oa.readyState == XMLHttpRequest.LOADING ? Pa + 1 : Pa, 0) } addProgress(Pa) { this.progress && (this.progress.value += Pa) } addSize(Pa) { this.progress && (this.progress.max = this.progress.hasAttribute("max") ? this.progress.max + Pa : Pa), this.updateStatus() } completedFile() { this.updateStatus() } failedFile(Pa, Oa) { this.abort(Pa + ": " + Oa) } completedQueue() { return this.progress && (this.progress.value = this.progress.max, this.progress.classList.toggle(Ne, !0)), this.status = Be.STATUS_IDLE, !0 } updateStatus() { if (!this.message) return !1; let Oa, Pa = this.queuedCount - this.completedCount; return Oa = 3 < Pa ? "There are " + Pa + " more to go\u2026" : 0 < Pa ? "Only " + Pa + " more to go\u2026" : "Sequence completed!", this.message.textContent = Oa, !0 } clearProgress(Pa = null) { return this.queue = [], this.progress && (this.progress.classList.toggle(Ne, !1), this.progress.removeAttribute("value"), this.progress.removeAttribute("max")), this.message && (this.message.textContent = Pa), !0 } abort(Pa = "Sequence aborted!") { this.queue.forEach(Oa => Oa.abort()), this.clearProgress(Pa) } async loadPackage(Pa) { let Oa = await this.load(Pa.url, "blob", Pa.files.reduce((Na, Ba) => Na += Ba.size, 0)), wa = 0, Fa = new Map; return Pa.files.forEach(Na => Fa.set(Na.name, Oa.slice(wa, wa += Na.size, Na.type))), Fa } async loadText(Pa) { return await this.load(Pa, "text", size) } async loadXML(Pa, Oa = 1) { return await this.load(Pa, "document", Oa) } load(Pa, Oa = "blob", wa = 1) { this.basePath && (Pa = new URL(Pa, this.basePath)), this.completedCount == this.queuedCount && this.clearProgress(); let Fa = 0; const Na = new XMLHttpRequest; "text" === Oa ? Na.overrideMimeType("text/plain") : "blob" === Oa ? Na.overrideMimeType("application/octet-stream") : "document" === Oa ? Na.overrideMimeType("application/xml") : void 0, Na.open("GET", Pa, !0), Na.responseType = Oa; return Na.onprogress = Ma => { return !!Ma.lengthComputable && void (0 < wa && this.addProgress((Ma.loaded - Fa) / Ma.total * wa), Fa = Ma.loaded) }, this.queue.push(Na), 0 < wa && this.addSize(wa), new Promise((Ma, ja) => { const Ya = Ga => { return this.failedFile(Ga.target.responseURL, Ga.target.statusText), ja(Ga.target.statusText), !1 }; Na.onload = Ga => { if (200 != Ga.target.status) return Ya(Ga); !Ga.lengthComputable && 0 < wa && this.addProgress(wa), this.completedFile(Ga.target.responseURL), this.completedCount == this.queuedCount && this.completedQueue(); let Xa = Ga.target.response; return "blob" == Oa && (Xa = new File([Xa], Pa)), Ma(Xa), !0 }, Na.onerror = Ya, Na.send(), this.status = Be.STATUS_BUSY }) } } Be.STATUS_IDLE = 0, Be.STATUS_BUSY = 1; class Me { constructor(Pa, Oa = 0, wa = 0) { if (!(Pa instanceof ArrayBuffer)) throw new TypeError("Invalid array buffer object type"); if (!(Number.isInteger(Oa) && 0 <= Oa)) throw new RangeError("Invalid byte offset"); if (!(Number.isInteger(wa) && Oa + wa <= Pa.byteLength)) throw new RangeError("Invalid byte length"); wa || (wa = Pa.byteLength - Oa), this.buffer = Pa, this.byteOffset = Oa, this.byteLength = wa } static from(Pa, Oa = 0, wa = 0) { if (!ArrayBuffer.isView(Pa)) throw new TypeError("Invalid view object type"); if (!(Number.isInteger(wa) && Oa + wa <= Pa.byteLength)) throw new RangeError("Invalid byte length"); return wa || (wa = Pa.byteLength - Oa), new this(Pa.buffer, Pa.byteOffset + Oa, wa) } clone() { return new this.constructor(this.buffer, this.byteOffset, this.byteLength) } move(Pa) { this.byteOffset += Pa, this.byteLength -= Pa } skip(Pa) { if (!(Number.isInteger(Pa) && 0 <= Pa)) return !1; if (Pa > this.byteLength) throw new RangeError("Exceeds remaining bytes"); return this.move(Pa), !0 } copy(Pa) { if (!Pa) Pa = this.byteLength; else if (Pa > this.byteLength) throw new RangeError("Exceeds remaining bytes"); let Oa = this.buffer.slice(this.byteOffset, this.byteOffset + Pa); return this.move(Pa), Oa } readString(Pa = 0) { if (!Pa) Pa = this.byteLength; else if (Pa > this.byteLength) throw new RangeError("Exceeds remaining bytes"); let Oa = new Uint8Array(this.buffer, this.byteOffset, Pa), wa = Oa.indexOf(0); return this.move(Pa), String.fromCharCode(...(0 <= wa ? Oa.subarray(0, wa) : Oa)) } readTypedArray(Pa, Oa = 0) { if (!(Number.isInteger(Oa) && 0 <= Oa)) throw new RangeError("Invalid element count"); else Oa || (Oa = Math.floor(this.byteLength / Pa.BYTES_PER_ELEMENT)); let wa, Fa = Pa.BYTES_PER_ELEMENT * Oa; if (Fa > this.byteLength) throw new RangeError("Exceeds remaining bytes"); return wa = new Pa(this.buffer, this.byteOffset, Oa), this.move(Fa), wa } readView(Pa) { if (!Pa) Pa = this.byteLength; else if (Pa > this.byteLength) throw new RangeError("Exceeds remaining bytes"); let Oa = new DataView(this.buffer, this.byteOffset, Pa); return this.move(Pa), Oa } readInteger(Pa = !1) { if (!this.byteLength) throw new RangeError("Exceeds remaining bytes"); let Oa = new DataView(this.buffer, this.byteOffset, 4 < this.byteLength ? 4 : this.byteLength), wa = 0; return 4 == this.byteLength ? wa = Pa ? Oa.getInt32(0, !0) : Oa.getUint32(0, !0) : 2 <= this.byteLength ? wa = Pa ? Oa.getInt16(0, !0) : Oa.getUint16(0, !0) : 1 == this.byteLength && (wa = Pa ? Oa.getInt8(0) : Oa.getUint8(0)), this.move(Oa.byteLength), wa } readInt8(Pa = 0, Oa = !1) { return this.readTypedArray(Oa ? Int8Array : Uint8Array, Pa) } readInt16(Pa = 0, Oa = !1) { return this.readTypedArray(Oa ? Int16Array : Uint16Array, Pa) } readInt32(Pa = 0, Oa = !1) { return this.readTypedArray(Oa ? Int32Array : Uint32Array, Pa) } readFloat32(Pa = 0) { return this.readTypedArray(Float32Array, Pa) } readVector2D() { return this.readFloat32(2) } readVector3D() { return this.readFloat32(3) } readVector4D() { return this.readFloat32(4) } readMatrix3x3() { return this.readFloat32(9) } readMatrix4x3() { return this.readFloat32(12) } readMatrix4x4() { return this.readFloat32(16) } } const Ge = 56, Xe = 44, Ve = Symbol("UTF entry origin reader"); class ke { constructor(Pa, Oa = 0, wa = 0, Fa = 0, Na = 0) { this.offset = Pa, this.nameOffset = Oa, this.nextOffset = wa, this.childOffset = Fa, this.dataSize = Na } get reader() { return this[Ve] } get name() { return this[Ve].getEntryName(this.nameOffset) } get tag() { return this.name.toLowerCase() } get hasSibling() { return 0 < this.nextOffset } get hasChild() { return 0 == this.dataSize && 0 < this.childOffset } get hasData() { return 0 < this.dataSize && 0 <= this.childOffset } get data() { if (!(this.reader instanceof We && this.hasData)) return !1; if (this.childOffset + this.dataSize > this.reader.data.size) throw new RangeError("Entry data is out of bounds"); let Pa = this.reader.data.slice(this.childOffset, this.childOffset + this.dataSize); return new Me(Pa) } find(...Pa) { if (!this.hasChild) return []; Pa = Pa.map(Na => "string" == typeof Na ? Na.toLowerCase() : void 0); let Fa, Oa = Array(Pa.length), wa = Pa.reduce((Na, Ba) => "string" == typeof Ba ? Na + 1 : Na, 0); for (let [Na, Ba] of this) if (!wa) break; else 0 <= (Fa = Pa.indexOf(Na)) && void 0 == Oa[Fa] && (Oa[Fa] = Ba, wa--); return Oa } *[Symbol.iterator]() { if (!this.hasChild) return !1; for (let Oa, Pa = this.childOffset; 0 < Pa;)Oa = this.reader.getEntry(Pa), Pa = Oa.nextOffset, yield [Oa.tag, Oa] } } class We { constructor() { this.tree = void 0, this.names = void 0, this.data = void 0, this.filename = void 0 } static async load(Pa) { if (!(Pa instanceof Blob)) throw new TypeError("Invalid blob object"); if (Pa.size < Ge + Xe) throw new RangeError("Blob size too small for UTF"); let [Oa, wa, Fa, Na, Ba, Ma, ja, Ya, Ga, Xa] = new Uint32Array((await T(Pa, 0, Ge))); const Ha = Object.create(this.prototype); if (Oa != 541480021) throw new TypeError("Invalid UTF file"); if (wa != 257) throw new TypeError("Invalid UTF version"); if (Ma != Xe) throw new TypeError("Invalid UTF entry size"); if (Fa > Pa.size) throw new RangeError("Tree offset is out of bounds"); if (0 == Na) throw new RangeError("Tree has no size"); if (ja > Pa.size) throw new RangeError("Dictionary offset is out of bounds"); if (Ga > Ya) throw new RangeError("Dictionary used size exceeds allocated size"); if (Xa > Pa.size) throw new RangeError("Data offset is out of bounds"); Pa instanceof File && (Ha.filename = Pa.name); let [Va, ka, Wa] = await Promise.all([T(Pa, Fa, Na), T(Pa, ja, Ya), T(Pa, Xa)]); return Ha.tree = Va, Ha.names = new Uint8Array(ka), Ha.data = Wa, Ha } getEntry(Pa = 0) { if (!(this.tree instanceof ArrayBuffer)) throw new TypeError("Reader has no tree buffer"); if (!Number.isInteger(Pa) || 0 > Pa || Pa > this.tree.size - 8) throw new RangeError("Invalid entry offset value"); let [Oa, wa, Fa, Na, Ba, Ma, ja, Ya] = new Uint32Array(this.tree, Pa, Xe / Uint32Array.BYTES_PER_ELEMENT); Fa & 16 && (ja = 0); let Ga = new ke(Pa, wa, Oa, Ba, ja); return Ga[Ve] = this, Ga } getEntryName(Pa = 0) { return String.fromCharCode(...this.names.subarray(Pa, this.names.indexOf(0, Pa))) } get root() { return this.getEntry(0) } } const qe = 11 * Uint32Array.BYTES_PER_ELEMENT, $e = 827611204, et = 861165636, tt = 894720068, rt = [31744, 992, 31]; class at { constructor(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object type"); let Ka, Oa = Pa.readView(18), wa = Oa.getUint8(0), Fa = Oa.getUint8(1), Na = Oa.getUint8(2), Ba = Oa.getUint16(3, !0), Ma = Oa.getUint16(5, !0), ja = Oa.getUint8(7), Ya = Oa.getUint16(8, !0), Ga = Oa.getUint16(10, !0), Xa = Oa.getUint16(12, !0), Ha = Oa.getUint16(14, !0), Va = Oa.getUint8(16), ka = Oa.getUint8(17), Wa = Xa * Ha, za = 1 == Na && Fa ? ja : Va, qa = 1 == Na ? Ma : Wa; Pa.skip(wa); let Za, Ja = 16 == za ? Pa.readInt16(qa) : Pa.readInt8(qa * za / 8); if (1 == Na) Za = Pa.readInt8(Wa * Va / 8); else if (2 != Na) throw new TypeError("Unsupported targa image type"); if (Ja instanceof Uint16Array) Ka = S(Ja, Xa, Ha, ...rt), za = 24; else if (Ja instanceof Uint8Array) { Ka = new Uint8Array(Wa * za / 8); for (let ei, Qa = 0, $a = 0; Qa < Wa; Qa++)ei = (Za ? Za[Qa] : Qa) * za / 8, Ka[$a++] = Ja[ei + 2], Ka[$a++] = Ja[ei + 1], Ka[$a++] = Ja[ei], 32 == za && (Ka[$a++] = Ja[ei + 3]) } this.width = Xa, this.height = Ha, this.depth = za, this.bitmap = Ka } } class it { constructor(Pa) { let Oa = Pa.clone(), [wa, Fa, Na, Ba, Ma, ja, Ya, Ga] = Pa.readInt32(8); if (wa != 542327876) throw new TypeError("Invalid DDS header"); if (!(Na & 4096)) throw new TypeError("DDS is missing pixel format header"); Na & 131072 || (Ga = 1), this.flags = Na, this.height = Ba, this.width = Ma, this.pitch = ja, this.depth = Ya, this.fourCC = void 0, this.bitCount = 0, this.masks = void 0, Oa.skip(Fa + Uint32Array.BYTES_PER_ELEMENT), Pa.skip(qe); let [Xa, Ha, Va, ka, Wa, za, qa, Ka] = Pa.readInt32(8); this.pixelFlags = Ha, Ha & 4 ? this.fourCC = Va : Ha & 64 && (this.bitCount = ka, this.masks = [Wa, za, qa, Ka]), this.mipmaps = []; for (let Ja = 0; Ja < Ga; Ja++) { let Za; switch (!0) { case 8 == this.bitCount: Za = Oa.readInt8(Ma * Ba); break; case 16 == this.bitCount: Za = Oa.readInt16(Ma * Ba); break; case 24 == this.bitCount: Za = Oa.readInt8(3 * (Ma * Ba)); break; case 32 == this.bitCount: Za = Oa.readInt8(4 * (Ma * Ba)); break; case this.fourCC == $e: Za = Oa.readInt8(8 * (Ma / 4 * Ba / 4)); break; case this.fourCC == et: case this.fourCC == tt: Za = Oa.readInt8(16 * (Ma / 4 * Ba / 4)); }this.mipmaps[Ja] = Za, Ma >>= 1, Ba >>= 1 } } } class nt { constructor() { this.height = 1, this.width = 1, this.depth = 24, this.alpha = !1, this.type = nt.TYPE_RGB24_888, this.mipmaps = [new Uint8Array(3)], this.mipmaps[0].fill(1) } *getMipmaps() { for (let Fa, Pa = this.width, Oa = this.height, wa = 0; 0 < Pa && 0 < Oa;) { if (Fa = this.mipmaps[wa], !Fa) return; yield [wa, Pa, Oa, Fa], wa++ , Pa >>= 1, Oa >>= 1 } } static fromTarga(...Pa) { if (!Pa.length) throw new RangeError("No targa images are specified"); let wa, Fa, Oa = new this; Oa.mipmaps = []; for (let Ba, Na = 0; Na < Pa.length; Na++) { if (Ba = Pa[Na], !(Ba instanceof at)) throw new TypeError("Invalid Targa image object type"); if (0 == Na) switch (Oa.width = wa = Ba.width, Oa.height = Fa = Ba.height, Oa.depth = Ba.depth, Ba.depth) { case 24: Oa.type = nt.TYPE_RGB24_888; break; case 32: Oa.type = nt.TYPE_RGBA32_8888; } else if (Ba.width != wa || Ba.height != Fa) throw new RangeError("Invalid mipmap (" + Na + ") image resolution"); Oa.mipmaps[Na] = Ba.bitmap, wa >>= 1, Fa >>= 1 } return Oa } static fromDDS(Pa) { if (!(Pa instanceof it)) throw new TypeError("Invalid DirectDraw Surface image object type"); let Oa = new this; if (Pa.bitCount) { let [wa, Fa, Na, Ba] = Pa.masks; switch (Pa.bitCount) { case 16: if (63488 == wa && 2016 == Fa && 31 == Na && 0 == Ba) Oa.type = nt.TYPE_RGB16_565; else if (3840 == wa && 240 == Fa && 15 == Na && 61440 == Ba) Oa.type = nt.TYPE_RGBA16_4444; else if (31744 == wa && 992 == Fa && 31 == Na && 32768 == Ba) Oa.type = nt.TYPE_RGBA16_5551; else throw new RangeError("Unsupported 16-bit color mask"); 0 < Ba && (Oa.alpha = !0); break; case 24: if (16711680 == wa && 65280 == Fa && 255 == Na && 0 == Ba) Oa.type = nt.TYPE_RGB24_888; else throw new RangeError("Unsupported 24-bit color mask"); break; case 32: if (16711680 == wa && 65280 == Fa && 255 == Na && 4278190080 == Ba) Oa.type = nt.TYPE_RGBA32_8888; else throw new RangeError("Unsupported 32-bit color mask"); Oa.alpha = !0; break; default: throw new RangeError("Unsupported uncompressed bit depth"); }Oa.depth = Pa.bitCount } else if (Pa.fourCC) { switch (Pa.fourCC) { case $e: Oa.alpha = !0, Oa.type = nt.TYPE_S3TC_DXT1; break; case et: Oa.alpha = !0, Oa.type = nt.TYPE_S3TC_DXT3; break; case tt: Oa.alpha = !0, Oa.type = nt.TYPE_S3TC_DXT5; break; default: throw new RangeError("Unsupported compression method"); }Oa.depth = Oa.alpha ? 32 : 24 } return Oa.width = Pa.width, Oa.height = Pa.height, Oa.mipmaps = Pa.mipmaps, Oa } } nt.TYPE_RGB16_565 = 0, nt.TYPE_RGBA16_4444 = 1, nt.TYPE_RGBA16_5551 = 2, nt.TYPE_RGB24_888 = 3, nt.TYPE_RGBA32_8888 = 4, nt.TYPE_S3TC_DXT1 = 5, nt.TYPE_S3TC_DXT3 = 7, nt.TYPE_S3TC_DXT5 = 8; class st { constructor() { this.shader = "standard-vertex", this.diffuseColor = new Float32Array(3), this.diffuseColor.fill(1), this.opacity = 1 } load() { } } class ot extends st { constructor() { super() } load(Pa) { let [Oa, wa, Fa, Na, Ba, Ma, ja] = Pa.find("dc", "dt_name", "dt_flags", "oc", "ec", "et_name", "et_flags"); this.type.includes("Dc") && Oa && (this.diffuseColor = Oa.data.readFloat32(3)), this.type.includes("Dt") && wa && (this.diffuseTexture = u(wa.data.readString()), Fa && (this.diffuseFlags = Fa.data.readInteger())), this.type.includes("Oc") && Na && (this.alpha = !0, Na && ([this.opacity] = Na.data.readFloat32(1))), this.type.includes("Ec") && Ba && (this.emissionColor = Ba.data.readFloat32(3)), this.type.includes("Et") && Ma && (this.emissionTexture = Ma.data.readString(), ja && (this.emissionFlags = ja.data.readInteger())) } } class dt extends st { load(Pa) { let [Oa, wa] = Pa.find("bt_name", "bt_flags"); this.detailTexture = Oa.data.readString(), wa && (this.detailFlags = wa.data.readInteger()) } } class lt extends st { load(Pa) { let [Oa, wa, Fa, Na, Ba] = Pa.find("dc", "dt_name", "dt_flags", "oc", "ec"); Oa && (this.diffuseColor = Oa.data.readFloat32(3)), wa && (this.diffuseTexture = wa.data.readString(), Fa && (this.diffuseFlags = Fa.data.readInteger())), Na && (this.alpha = !0, Na && ([this.opacity] = Na.data.readFloat32(1))), Ba && (this.emissionColor = Ba.data.readFloat32(3)) } } class ut extends st { load(Pa) { let [Oa, wa] = Pa.find("nt_name", "nt_flags"); this.nomadTexture = Oa.data.readString(), wa && (this.nomadFlags = wa.data.readInteger()) } } class mt extends st { constructor() { super(), this.alpha = !0, this.shader = "glass" } load(Pa) { let [Oa, wa] = Pa.find("dc", "oc"); Oa && (this.diffuseColor = Oa.data.readFloat32(3)), wa && ([this.opacity] = wa.data.readFloat32(1)) } } class ct { constructor() { this.vertex = "", this.fragment = "", this.version = 0 } load(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object"); if (!Pa.hasChild) return !1; let [Oa, wa, Fa] = Pa.find("vertexshader", "fragmentshader", "version"); return Oa && wa && (this.vertex = Oa.data.readString(), this.fragment = wa.data.readString(), Fa && ([this.version] = Fa.data.readFloat32(1)), !0) } loadXML(Pa) { if (!(Pa instanceof Element)) throw new TypeError("Invalid XML element object"); if (!Pa.hasChildNodes()) return !1; let Oa, wa, Fa; for (let Na of Pa.children) switch (Na.nodeName) { case "vertex-shader": Oa = Na; break; case "fragment-shader": wa = Na; break; case "version": Fa = Na; }return Oa && wa && (this.vertex = Oa.textContent, this.fragment = wa.textContent, Fa && (this.version = parseFloat(verison.textContent)), !0) } } const ft = 2, gt = 16, pt = 64, ht = 128, Et = 3 * Float32Array.BYTES_PER_ELEMENT, vt = 3 * Float32Array.BYTES_PER_ELEMENT, bt = 4 * Uint8Array.BYTES_PER_ELEMENT, xt = 4 * Uint8Array.BYTES_PER_ELEMENT, St = 2 * Float32Array.BYTES_PER_ELEMENT; class yt { constructor(Pa = 0, Oa = 0, wa = 0, Fa = 0, Na = 0, Ba = 0) { this.minimum = new Float32Array([Oa, Fa, Ba]), this.maximum = new Float32Array([Pa, wa, Na]) } load(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object"); let [Oa, wa, Fa, Na, Ba, Ma] = Pa.readFloat32(6); return this.minimum.set([wa, Na, Ma]), this.maximum.set([Oa, Fa, Ba]), !0 } get size() { return [this.maximum[0] - this.minimum[0], this.maximum[1] - this.minimum[1], this.maximum[2] - this.minimum[2]] } } class It { constructor(Pa = 0, Oa = 0, wa = 0, Fa = 0) { this.center = new Float32Array([Pa, Oa, wa]), this.radius = Fa } load(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object"); let [Oa, wa, Fa, Na] = Pa.readFloat32(4); return this.center.set([Oa, wa, Fa]), this.radius = Na, !0 } get maxRadius() { return Math.sqrt(this.center[0] * this.center[0] + this.center[1] * this.center[1] + this.center[2] * this.center[2]) + this.radius } } class At { constructor(Pa = 0, Oa = 0, wa = 0, Fa = 0, Na = 0, Ba = 0, Ma = 0) { this.meshID = Pa, this.vertexStart = Oa, this.vertexCount = wa, this.indexStart = Fa, this.indexCount = Na, this.groupStart = Ba, this.groupCount = Ma, this.box = new yt, this.sphere = new It } load(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object"); let Oa; if ([Oa, this.meshID] = Pa.readInt32(2), Oa != 60) throw new RangeError("Invalid mesh reference size"); return [this.vertexStart, this.vertexCount, this.indexStart, this.indexCount, this.groupStart, this.groupCount] = Pa.readInt16(6), this.box.load(Pa), this.sphere.load(Pa), !0 } } class Rt { constructor(Pa = 0, Oa = 0, wa = 0, Fa = 0) { this.materialID = Pa, this.vertexStart = Oa, this.vertexEnd = wa, this.indexCount = Fa, this.unknown = 0 } load(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object"); return [this.materialID] = Pa.readInt32(1), [this.vertexStart, this.vertexEnd, this.indexCount, this.unknown] = Pa.readInt16(4), !0 } get vertexCount() { return this.vertexEnd - this.vertexStart + 1 } } class Dt { constructor(Pa = 1, Oa = 4, wa = 0) { this.type = Pa, this.surface = Oa, this.format = wa, this.scale = 1, this.groups = [], this.indices = void 0, this.vertices = void 0 } set format(Pa) { this.hasPosition = 0 < (Pa & ft), this.hasNormal = 0 < (Pa & gt), this.hasDiffuse = 0 < (Pa & pt), this.hasSpecular = 0 < (Pa & ht), this.mapCount = (Pa & 3840) >> 8, this.vertexLength = 0, this.hasPosition && (this.vertexLength += Et), this.hasNormal && (this.vertexLength += vt), this.hasDiffuse && (this.vertexLength += bt), this.hasSpecular && (this.vertexLength += xt), this.vertexLength += this.mapCount * St, this.positionOffset = this.hasPosition ? 0 : void 0, this.normalOffset = this.hasNormal ? this.hasPosition ? Et : 0 : void 0, this.diffuseOffset = this.hasDiffuse ? (this.hasPosition ? Et : 0) + (this.hasNormal ? vt : 0) : void 0, this.specularOffset = this.hasSpecular ? (this.hasPosition ? Et : 0) + (this.hasNormal ? vt : 0) + (this.hasDiffuse ? bt : 0) : void 0, this.mapOffset = this.mapCount ? (this.hasPosition ? Et : 0) + (this.hasNormal ? vt : 0) + (this.hasDiffuse ? bt : 0) + (this.hasSpecular ? xt : 0) : void 0 } get format() { let Pa = 0; return this.hasPosition && (Pa |= ft), this.hasNormal && (Pa |= gt), this.hasDiffuse && (Pa |= pt), this.hasSpecular && (Pa |= ht), Pa |= this.mapCount << 8, Pa } get vertexCount() { return this.vertices.byteLength / this.vertexLength } getMapOffset(Pa = 0) { return Pa < this.mapCount ? this.mapOffset + Pa * St : null } *getGroupsByReference(Pa) { for (let Oa = 0; Oa < Pa.groupCount; Oa++)yield this.groups[Pa.groupStart + Oa] } load(Pa) { if (!(Pa instanceof Me)) throw new TypeError("Invalid data object"); let [Oa, wa] = Pa.readInt32(2); if (1 != Oa) throw new TypeError("Unrecognized mesh type"); if (4 != wa) throw new TypeError("Unrecognized surface type"); let [Fa, Na, Ba, Ma] = Pa.readInt16(4); this.format = Ba, this.groups = []; for (let ja = 0; ja < Fa; ja++)(this.groups[ja] = new Rt).load(Pa); if (this.indices = Pa.readInt16(Na), this.vertices = Pa.readInt8(Ma * this.vertexLength), Ma != this.vertexCount) throw new RangeError("Mesh has invalid number of vertices"); return !0 } getPositions() { if (!this.hasPosition) return !1; const Pa = this.vertexCount, Oa = this.vertexLength, wa = new DataView(this.vertices.buffer, this.vertices.byteOffset, this.vertices.byteLength), Fa = new Float32Array(3 * Pa); for (let Na = 0, Ba = 0, Ma = 0; Na < Pa; Na++)Ma = Na * Oa, Fa[Ba++] = wa.getFloat32(Ma, !0), Fa[Ba++] = wa.getFloat32(Ma + 4, !0), Fa[Ba++] = wa.getFloat32(Ma + 8, !0); return Fa } } class Ct { constructor(Pa = 0, Oa = 0, wa = 0, Fa = 0) { this.meshID = Pa, this.vertexStart = Oa, this.vertexCount = wa, this.vertexRange = Fa, this.indices = void 0 } load(Pa) { let Oa; if ([Oa, this.meshID] = Pa.readInt32(2), 16 != Oa) throw new RangeError("Invalid wire reference size"); return [this.vertexStart, this.vertexCount, this.indexCount, this.vertexRange] = Pa.readInt16(4), this.indices = Pa.readInt16(this.indexCount), !0 } } const Lt = Object.create(null); Lt.LINES = 0, Lt.STRIP = 1, Lt.LOOP = 2; class Ft { constructor() { this.splines = [], this.indices = void 0, this.positions = void 0, this.colors = void 0 } load(Pa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object"); if (!Pa.hasChild) throw new RangeError("Shape folder is empty"); let [Oa, wa, Fa, Na] = Pa.find("splines", "indices", "positions", "colors"); if (!Oa) throw new Error("Shape is missing splines entry"); if (!wa) throw new Error("Shape is missing indices entry"); if (!Fa) throw new Error("Shape is missing positions entry"); return this.indices = wa.data.readInt16(), this.positions = Fa.data.readFloat32(), Na && (this.colors = Na.data.readInt8()), !0 } } let Bt = "undefined" == typeof Float32Array ? Array : Float32Array; const Mt = Math.PI / 180, Yt = function () { let Pa = Y(); return function (Oa, wa, Fa, Na, Ba, Ma) { let ja, Ya; for (wa || (wa = 3), Fa || (Fa = 0), Ya = Na ? Math.min(Na * wa + Fa, Oa.length) : Oa.length, ja = Fa; ja < Ya; ja += wa)Pa[0] = Oa[ja], Pa[1] = Oa[ja + 1], Pa[2] = Oa[ja + 2], Ba(Pa, Pa, Ma), Oa[ja] = Pa[0], Oa[ja + 1] = Pa[1], Oa[ja + 2] = Pa[2]; return Oa } }(), Gt = function () { let Pa = re(); return function (Oa, wa, Fa, Na, Ba, Ma) { let ja, Ya; for (wa || (wa = 4), Fa || (Fa = 0), Ya = Na ? Math.min(Na * wa + Fa, Oa.length) : Oa.length, ja = Fa; ja < Ya; ja += wa)Pa[0] = Oa[ja], Pa[1] = Oa[ja + 1], Pa[2] = Oa[ja + 2], Pa[3] = Oa[ja + 3], Ba(Pa, Pa, Ma), Oa[ja] = Pa[0], Oa[ja + 1] = Pa[1], Oa[ja + 2] = Pa[2], Oa[ja + 3] = Pa[3]; return Oa } }(), Xt = function (Pa, Oa) { return Pa[0] = Oa[0], Pa[1] = Oa[1], Pa[2] = Oa[2], Pa[3] = Oa[3], Pa }, Ht = function (Pa, Oa) { let wa = Oa[0], Fa = Oa[1], Na = Oa[2], Ba = Oa[3], Ma = wa * wa + Fa * Fa + Na * Na + Ba * Ba; return 0 < Ma && (Ma = 1 / Math.sqrt(Ma)), Pa[0] = wa * Ma, Pa[1] = Fa * Ma, Pa[2] = Na * Ma, Pa[3] = Ba * Ma, Pa }, Vt = function () { let Pa = Y(), Oa = X(1, 0, 0), wa = X(0, 1, 0); return function (Fa, Na, Ba) { let Ma = Q(Na, Ba); return -0.999999 > Ma ? ($(Pa, Oa, Na), 1e-6 > G(Pa) && $(Pa, wa, Na), Z(Pa, Pa), se(Fa, Pa, Math.PI), Fa) : 0.999999 < Ma ? (Fa[0] = 0, Fa[1] = 0, Fa[2] = 0, Fa[3] = 1, Fa) : ($(Pa, Na, Ba), Fa[0] = Pa[0], Fa[1] = Pa[1], Fa[2] = Pa[2], Fa[3] = 1 + Ma, Ht(Fa, Fa)) } }(), kt = function () { let Pa = ne(), Oa = ne(); return function (wa, Fa, Na, Ba, Ma, ja) { return de(Pa, Fa, Ma, ja), de(Oa, Na, Ba, ja), de(wa, Pa, Oa, 2 * ja * (1 - ja)), wa } }(), Wt = function () { let Pa = A(); return function (Oa, wa, Fa, Na) { return Pa[0] = Fa[0], Pa[3] = Fa[1], Pa[6] = Fa[2], Pa[1] = Na[0], Pa[4] = Na[1], Pa[7] = Na[2], Pa[2] = -wa[0], Pa[5] = -wa[1], Pa[8] = -wa[2], Ht(Oa, ue(Oa, Pa)) } }(), zt = function () { let Pa = me(); return function (Oa, wa, Fa, Na, Ba, Ma) { let ja, Ya; for (wa || (wa = 2), Fa || (Fa = 0), Ya = Na ? Math.min(Na * wa + Fa, Oa.length) : Oa.length, ja = Fa; ja < Ya; ja += wa)Pa[0] = Oa[ja], Pa[1] = Oa[ja + 1], Ba(Pa, Pa, Ma), Oa[ja] = Pa[0], Oa[ja + 1] = Pa[1]; return Oa } }(); class or { constructor() { this.transform = new Float32Array(16) } load(Pa) { let Oa = Pa.readVector3D(), wa = Pa.readMatrix3x3(); fe(this.transform, Oa, wa) } } class dr extends or { } class lr { constructor() { this.transform = new Float32Array(16), this.offset = new Float32Array(3), this.axis = new Float32Array(3), this.min = 0, this.max = 0 } load(Pa) { let Oa = Pa.readVector3D(), wa = Pa.readVector3D(), Fa = Pa.readMatrix3x3(), Na = Pa.readVector3D(), Ba = Pa.readVector2D(); fe(this.transform, Oa, Fa), this.offset = wa.slice(), this.axis = Na.slice(), this.min = Ba[0], this.max = Ba[1] } } class ur extends lr { } class mr { constructor() { this.transform = new Float32Array(16), this.axis = new Float32Array(3), this.min = new Float32Array(2), this.max = new Float32Array(2) } load(Pa) { let Oa = Pa.readVector3D(), wa = Pa.readMatrix3x3(), Fa = Pa.readVector3D(), Na = Pa.readVector4D(); fe(this.transform, Oa, wa), this.axis = Fa.slice(), this.min[0] = Na[0], this.min[1] = Na[2], this.max[0] = Na[1], this.max[1] = Na[3] } } class cr { constructor() { this.transform = new Float32Array(16), this.offset = new Float32Array(3), this.min = new Float32Array(3), this.max = new Float32Array(3) } load(Pa) { let Oa = Pa.readVector3D(), wa = Pa.readVector3D(), Fa = Pa.readMatrix3x3(), Na = Pa.readFloat32(6); fe(this.transform, Oa, Fa), this.offset = wa.slice(), this.min[0] = Na[0], this.min[1] = Na[2], this.min[2] = Na[4], this.max[0] = Na[1], this.max[1] = Na[3], this.max[2] = Na[5] } } class Sr { constructor() { this.transform = new Float32Array(16) } load(Pa, Oa) { if (!(Pa instanceof ke)) throw new TypeError("Invalid UTF entry object type"); if (!Pa.hasChild) return !1; let [wa, Fa] = Pa.find("position", "orientation"); if (!wa) throw new RangeError("Hardpoint " + Oa + " is missing position entry"); if (!Fa) throw new RangeError("Hardpoint " + Oa + " is missing orientation entry"); fe(this.transform, wa.data.readVector3D(), Fa.data.readMatrix3x3()) } } class _r extends Sr { constructor() { super(), this.axis = new Float32Array(3), this.min = 0, this.max = 0 } load(Pa, Oa) { super.load(Pa, Oa); let [wa, Fa, Na] = Pa.find("axis", "min", "max"); if (!wa) throw new RangeError("Hardpoint " + Oa + " is missing axis entry"); if (!Fa) throw new RangeError("Hardpoint " + Oa + " is missing min entry"); if (!Na) throw new RangeError("Hardpoint " + Oa + " is missing max entry"); return this.axis = wa.data.readVector3D(), [this.min] = Fa.data.readFloat32(1), [this.max] = Na.data.readFloat32(1), !0 } } class yr extends _r { } const Cr = Symbol("Pre-calculated transformation matrix"); class Lr { constructor() { this.root = void 0, this.hardpoints = new Map } attachHardpoint(Pa, Oa) { if ("string" != typeof Pa || !Pa.length) throw new TypeError("Invalid hardpoint name"); if (this.hardpoints.has(Pa)) throw new RangeError("Hardpoint already exists"); return this.hardpoints.set(Pa, Oa), !0 } getHardpoint(Pa) { return this.hardpoints.get(Pa) } getHardpoints() { return this.hardpoints } } class Ur extends Lr { constructor() { super(), this.parts = new Map, this.parents = new WeakMap, this.constraints = new WeakMap, this.indices = [] } addPart(Pa, Oa, wa = 0) { if ("string" != typeof Pa || !Pa.length) throw new TypeError("Invalid compound part name"); if (this.parts.has(Pa)) throw new RangeError("Compound part already exists"); return this.parts.set(Pa, Oa), Pa == "Root" && (this.root = Oa), this.indices[wa] = Oa, !0 } attachHardpoint(Pa, Oa, wa) { if ("string" == typeof wa && !(wa = this.parts.get(wa))) throw new RangeError("Could not find part with that name"); return super.attachHardpoint(Pa, Oa), this.parents.set(Oa, wa), !0 } attachPart(Pa, Oa, wa) { return "string" == typeof Pa && (Pa = this.getPart(Pa)), "string" == typeof Oa && (Oa = this.getPart(Oa)), this.parents.set(Pa, Oa), this.constraints.set(Pa, wa), !0 } getPart(Pa) { return this.parts.get(Pa) } getParent(Pa) { return "string" == typeof Pa && (Pa = this.getPart(Pa) || this.getHardpoint(Pa)), this.parents.get(Pa) } getConstraint(Pa) { return "string" == typeof Pa && (Pa = this.getPart(Pa)), Pa ? this.constraints.get(Pa) : void 0 } getPartTransform(Pa, Oa) { if ("string" == typeof Oa && (Oa = this.getPart(Oa)), !!Oa) { if (Oa[Cr]) return U(Pa, Pa, Oa[Cr]); let wa, Fa = Oa, Na = !0; for (; Fa && Fa != this.root;)wa = this.getConstraint(Fa), wa instanceof or || (Na = !1), U(Pa, wa.transform, Pa), wa.offset && P(Pa, Pa, wa.offset), Fa = this.getParent(Fa); return Na && (Oa[Cr] = C(Pa)), Pa } } *getTransforms(Pa, Oa = !1) { if (!(Pa instanceof Float32Array)) return !1; for (let [wa, Fa] of this.parts) yield [wa, Fa, this.getPartTransform(Pa, Fa)] } *getHardpoints(Pa = this.root) { for (let [Oa, wa] of this.hardpoints) this.parents.get(wa) === Pa && (yield [Oa, wa]) } *getChildren(Pa = this.root) { for (let [Oa, wa] of this.parts) this.parents.get(wa) === Pa && (yield [Oa, wa]) } load(Pa, Oa, wa) { if (!Pa instanceof ke) throw new TypeError("Invalid compound entry object type"); if (!Pa.hasChild) throw new RangeError("Compound entry is empty"); this.root = void 0, this.parts.clear(), this.hardpoints.clear(), this.parents = new WeakMap, this.constraints = new WeakMap, Oa || (Oa = Pa.reader.root); for (let [Fa, Na, Ba, Ma] of ve(Pa, Oa, wa)) if (this.addPart(Fa, Ma, Na)) for (let [ja, Ya] of Te(Ba)) this.attachHardpoint(ja, Ya, Ma); if (!this.root) throw new RangeError("Compound model is missing Root part"); for (let [Fa, Na, Ba] of pe(Pa)) this.attachPart(Fa, Na, Ba); return !0 } } const wr = "vmeshpart", Fr = "vmeshref", Mr = /^level(\d+)$/i; class jr { constructor() { this.ranges = [0], this.references = [] } setLevel(Pa, Oa, wa) { if (!(Oa instanceof At)) throw new TypeError("Invalid mesh reference object type"); return this.setRange(Pa, wa), this.references[Pa] = Oa, this.ranges[Pa + 1] = wa, !0 } setRange(Pa, Oa) { if ("number" != typeof Oa || 0 >= Oa) throw new RangeError("Invalid level range") } getLODReference(Pa) { let Oa = E(Pa, this.ranges); return this.references[Oa] } load(Pa) { let Oa, wa, Fa, Na; this.references = []; for (let [Ba, Ma] of Pa) switch (Ba) { case "switch2": this.ranges = Array.from(Ma.data.readFloat32()); continue; default: if (!(Oa = Mr.exec(Ba))) continue; Na = parseInt(Oa[1]), ([wa] = Ma.find(wr)) && ([Fa] = wa.find(Fr)) && (this.references[Na] = new At).load(Fa.data); }if (0 <= (Na = this.references.indexOf(void 0))) throw new RangeError("Missing reference data for LOD " + Na); return this.references.length } } class Yr { constructor() { this.mesh = void 0, this.wireframe = void 0 } load(Pa) { this.wireframe = void 0; let Na, Ba, [Oa, wa, Fa] = Pa.find("vmeshwire", wr, "multilevel"); if (Fa) (this.mesh = new jr).load(Fa); else if (wa && ([Na] = wa.find(Fr))) (this.mesh = new At).load(Na.data); else throw new RangeError("Part is missing mesh reference"); return Oa && ([Ba] = Oa.find("vwiredata")) && (this.wireframe = new Ct).load(Ba.data), !0 } getLODReference(Pa) { return this.mesh instanceof jr ? this.mesh.getLODReference(Pa) : !!(this.mesh instanceof At) && this.mesh } getLOD(Pa) { return this.mesh instanceof jr && Pa < this.mesh.references.length ? this.mesh.references[Pa] : this.mesh instanceof At && 1 > Pa && this.mesh } } class Gr extends Ur { load(Pa, Oa) { return super.load(Pa, Oa, Yr) } getRadius() { if (this.root) { let Pa = 0, Oa = D(), wa = Y(); for (let [Fa, Na] of this.getMeshes(0)) { O(Oa, Na.sphere.center), this.getPartTransform(Oa, Fa), N(wa, Oa); let Ba = G(wa) + G(Na.sphere.center) + Na.sphere.radius; Ba > Pa && (Pa = Ba) } return Pa } } *getMeshes(Pa = 0) { for (let Oa of this.parts.values()) { let wa = Oa.getLODReference(Pa); wa && (yield [Oa, wa]) } } *getWireframes() { let Oa, wa; for (let Fa of this.parts.values()) Fa.wireframe && Fa.wireframe.meshID && (Oa != Fa.wireframe.meshID && (wa = Glancer.resources.getMesh(Oa = Fa.wireframe.meshID)), wa && (yield [Fa, wa, Fa.wireframe])) } } class Xr extends Lr { load(Pa) { this.root = new Yr, this.root.load(Pa); for (let [Oa, wa] of Te(Pa)) this.attachHardpoint(Oa, wa); return !0 } getRadius() { if (this.root) { let Pa = this.root.getLODReference(0); return Pa.sphere.radius } } *getMeshes(Pa = 0) { if (!this.root) return !1; let Oa = this.root.getLODReference(Pa); if (!Oa) return !1; let wa = Glancer.resources.getMesh(meshID = Oa.meshID); return !!wa && void (yield [this.root, wa, Oa]) } } class Hr extends Lr { load(Pa) { let [Oa, wa] = Pa.find("radius", "sides"); wa = wa.data.readInteger(), [Oa] = Oa.data.readFloat32(1) } } const Kr = /^mip(\d)$/i, ea = new Map; ea.set(/^alpha_mask.*/, ot), ea.set(/^alpha_mask.*2side/, ot), ea.set(/^detailmap_.*/, dt), ea.set(/^tlr_material$/, lt), ea.set(/^tlr_energy$/, lt), ea.set(/^nomad.*$/, ut), ea.set(/^n-texture.*$/, ut), ea.set(/^exclusion_.*/, ot), ea.set(/^c_glass$/, mt), ea.set(/^cv_glass$/, mt), ea.set(/^b_glass$/, mt), ea.set(/^k_glass$/, mt), ea.set(/^l_glass$/, mt), ea.set(/^r_glass$/, mt), ea.set(/^planet.*_glass$/, mt), ea.set(/^bw_glass$/, mt), ea.set(/^o_glass$/, mt); const ta = new Map; ta.set("EcEtOcOt", "DcDtOcOt"), ta.set("DcDtEcEt", "DcDtEt"); const ra = new nt, aa = new st; aa.diffuseTexture = "null"; class ia { constructor(Pa) { if (!(Pa instanceof Be)) throw new TypeError("Invalid file loader type"); this.loader = Pa, this.textures = new Map, this.materials = new Map, this.meshes = new Map, this.shapes = new Map, this.models = new Map, this.shaders = new Map } async loadUTF(Pa, Oa = 1) { let wa = await this.loader.load(Pa, "blob", Oa), Fa = await We.load(wa); return Fa } getTexture(Pa) { let Oa = u(Pa), wa = this.textures.get(Oa); return wa || this.textures.set(Oa, wa = ra), wa } getMaterial(Pa) { let Oa = u(Pa), wa = this.materials.get(Oa); return wa || this.materials.set(Oa, wa = aa), wa } getMesh(Pa) { return this.meshes.get(u(Pa)) } getShape(Pa) { return this.shapes.get(u(Pa)) } getShader(Pa) { return this.shaders.get(u(Pa)) } getModel(Pa, Oa = 1) { let wa = u(Pa), Fa = this.models.get(wa); if (Fa) return Fa; let Na = this.loadUTF(Pa, Oa).then(Ba => { return this.loadLibraries(Ba, ia.LOAD_TEXTURES | ia.LOAD_MATERIALS | ia.LOAD_MESHES), _e(Ba) }); return this.models.set(wa, Na), Na } async getResources(Pa, Oa = 1, wa) { let Fa = await this.loadUTF(Pa, Oa); return this.loadLibraries(Fa, wa), Fa } loadLibraries(Pa, Oa = ia.LOAD_TEXTURES | ia.LOAD_MATERIALS) { if (!(Pa instanceof We)) throw new TypeError("Invalid UTF reader object type"); let wa = [], Fa = 0; Oa & ia.LOAD_TEXTURES && (wa[0] = "texture library"), Oa & ia.LOAD_MATERIALS && (wa[1] = "material library"), Oa & ia.LOAD_SHADERS && (wa[2] = "shader library"), Oa & ia.LOAD_MESHES && (wa[3] = "vmeshlibrary"), Oa & ia.LOAD_SHAPES && (wa[4] = "shape library"); let [Na, Ba, Ma, ja, Ya] = Pa.root.find(...wa); return Na && (Fa += ye(Na, be, this.textures, ra)), Ba && (Fa += ye(Ba, xe, this.materials, aa)), Ma && (Fa += ye(Ma, _, this.shaders)), ja && (Fa += ye(ja, Se, this.meshes)), Ya && (Fa += ye(Ya, I, this.shapes)), Fa } async loadShadersXML(Pa, Oa) { const wa = await this.loader.loadXML(Pa, Oa); if (!(wa instanceof XMLDocument)) throw new TypeError("Invalid XML document object"); for (let Fa of wa.documentElement.children) if (Fa.hasChildNodes()) switch (Fa.nodeName) { case "program": let Ja = Fa.getAttribute("name"), Za = new ct; Za.loadXML(Fa), this.shaders.set(u(Ja), Za); }return !0 } getMeshByReference(Pa, Oa = !1) { if (!(Pa instanceof At)) return !1; let wa = this.getMesh(Pa.meshID); if (!(wa instanceof Dt)) return !1; let Fa = new Dt(wa.type, wa.surface, wa.format); return Fa.groups = wa.groups.slice(Pa.groupStart, Pa.groupStart + Pa.groupCount), Fa.indices = wa.indices.subarray(Pa.indexStart, Pa.indexStart + Pa.indexCount), Fa.vertices = wa.vertices.subarray(Pa.vertexStart * wa.vertexLength, (Pa.vertexStart + Pa.vertexCount) * wa.vertexLength), Oa && (Fa.indices = Fa.indices.slice(), Fa.vertices = Fa.vertices.slice()), Fa } } ia.LOAD_TEXTURES = 1, ia.LOAD_MATERIALS = 2, ia.LOAD_SHADERS = 4, ia.LOAD_MESHES = 8, ia.LOAD_SHAPES = 16; class na { constructor() { this.position = Y(), this.rotation = ne(), this.rotationInverse = ne(), this.step = Y() } rotate(Pa) { Xt(this.rotation, Pa) } move(Pa) { K(this.position, this.position, Pa, 0.5) } moveLocal(Pa) { le(this.rotationInverse, this.rotation), te(this.step, Pa, this.rotation), V(this.position, this.position, this.step) } update() { } } const sa = Object.create(null); sa.DIRECTIONAL = 0, sa.SPOT = 1; class oa extends na { constructor() { super(), this.color = Y(), this.range = 1e3, this.type = sa.DIRECTIONAL } } class da extends na { constructor(Pa = 60 * Math.PI / 180, Oa = 1, wa = 1e4) { super(), this.fov = Pa, this.near = Oa, this.far = wa } update() { } } class la extends na { constructor(Pa) { if (super(), !(Pa instanceof Xr || Pa instanceof Gr)) throw new TypeError("Invalid rigid model type"); this.model = Pa, this.attachments = new Map } } const ga = "OES_vertex_array_object", ha = X(0, 0, 0), Ta = X(1, 1, 1), Ea = X(1, 0, 0), va = X(0, 1, 0), ba = X(0, 0, 1); class xa { constructor(Pa) { this.target = Pa, this.referenceData = new WeakMap, this.groupMaterial = new WeakMap, this.groupProgram = new WeakMap, this.opaques = [], this.translucents = [] } } class Sa extends xa { constructor(Pa) { super(Pa.model), this.target = Pa, this.modelMatrix = D() } } const _a = 6; class ya { constructor(Pa, Oa = !1, wa = !1) { if (!(Pa instanceof HTMLCanvasElement)) throw new TypeError("Invalid HTML canvas element object"); this.status = ya.STATUS_UNINITIALIZED; const Fa = Pa.getContext("experimental-webgl", { alpha: Oa, antialias: wa, preserveDrawingBuffer: !0 }); if (!Fa) throw new Error("Unable to get WebGL rendering context"); return this.context = Fa, this.extensions = { vertexArrays: Fa.getExtension(ga), anisotropicFilter: Fa.getExtension("EXT_texture_filter_anisotropic") }, Fa.enable(Fa.DEPTH_TEST), Fa.enable(Fa.CULL_FACE), Fa.enable(Fa.BLEND), Fa.cullFace(Fa.BACK), this.blankTexture = Pe(Fa), this.resources = void 0, this.input = void 0, this.frameCount = 0, this.drawCount = 0, this.transparent = Oa, this.width = 0, this.height = 0, this.aspectRatio = 0, this.scale = 1, this.LODbias = 1, this.mode = ya.DRAW_STARS | ya.DRAW_NEBULAE | ya.DRAW_OBJECTS | ya.DRAW_EFFECTS | ya.DRAW_OVERLAY | ya.DRAW_TEXTURES | ya.DRAW_LIGHTING, this.textures = new WeakMap, this.programs = new Map, this.vertexArrays = new WeakMap, this.meshGroups = new WeakSet, this.objects = new WeakMap, this.transforms = new WeakMap, this.matrices = new Ia, this.backdropPosition = Y(), this.backdropScalar = 0, this.ambientColor = Y(), this.highlightColor = Y(), this.lightPositions = new Float32Array(3 * _a), this.lightColors = new Float32Array(3 * _a), this.lightCount = 0, this.opaques = [], this.translucents = [], this.cursor = !1, this.cursorPosition = me(), this.cursorPixels = me(), this.targetPixels = me(), this.setupViewport(), this.status = ya.STATUS_INITIALIZED, !0 } setupViewport() { const Pa = this.context; if (!(Pa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!(Pa.canvas instanceof HTMLCanvasElement)) throw new TypeError("Rendering context does not have canvas element"); const Oa = getComputedStyle(Pa.canvas); return this.width = parseInt(Oa.getPropertyValue("width"), 10), this.height = parseInt(Oa.getPropertyValue("height"), 10), this.aspectRatio = this.width / this.height, Pa.canvas.width = this.width * this.scale, Pa.canvas.height = this.height * this.scale, Pa.viewport(0, 0, Pa.drawingBufferWidth, Pa.drawingBufferHeight), !0 } drawScene(Pa, Oa, wa, Fa) { const Na = this.context; if (this.input = wa, this.resources = Fa, this.status = ya.STATUS_STARTED, !Oa) return !1; if (this.drawCount = 0, Na.clearColor(Oa.color[0], Oa.color[1], Oa.color[2], this.transparent ? 0 : 1), Na.clear(Na.COLOR_BUFFER_BIT), Na.clear(Na.DEPTH_BUFFER_BIT), !Oa.camera) return !0; Na.bindTexture(Na.TEXTURE_2D, null), M(this.matrices.projection, Oa.camera.fov, this.aspectRatio, Oa.camera.near, Oa.camera.far), this.status = ya.STATUS_BACKDROP, B(this.matrices.view, Oa.camera.rotation), W(this.backdropPosition, Oa.camera.position, this.backdropScalar), P(this.matrices.view, this.matrices.view, this.backdropPosition), this.ambientColor.fill(1), this.lightCount = 0, this.mode & ya.DRAW_STARS && Oa.stars && this.drawRigidModel(Oa.stars), this.mode & ya.DRAW_NEBULAE && Oa.nebulae && this.drawRigidModel(Oa.nebulae), Na.clear(Na.DEPTH_BUFFER_BIT), this.status = ya.STATUS_OBJECTS, P(this.matrices.view, this.matrices.view, Oa.camera.position), Oa.ambient && H(this.ambientColor, Oa.ambient); for (let Ba of Oa.lights.values()) this.lightPositions.set(Ba.position, 3 * this.lightCount), this.lightColors.set(Ba.color, 3 * this.lightCount), this.lightCount++; if (this.mode & ya.DRAW_OBJECTS) for (let Ba of Oa.objects.values()) Ba instanceof la && this.drawRigidObject(Ba); return this.status = ya.STATUS_OVERLAYS, this.status = ya.STATUS_FINISHED, this.frameCount++ , !0 } getObjectTransform(Pa) { let Oa = this.transforms.get(Pa); return Oa || this.transforms.set(Pa, Oa = D()), Oa } drawRigidObject(Pa) { let Oa = this.getObjectTransform(Pa); return F(Oa, Pa.rotation, Pa.position), Pa.model && this.drawRigidModel(Pa.model, Oa, Pa.ranges), !0 } drawRigidModel(Pa, Oa, wa) { let Fa, Na, Ba, Ma = !1, ja = !1, Ya = !0; for (let Ga of Pa.parts.values()) Ma = !1, L(this.matrices.model), this.stackTransforms(this.matrices.model, Pa, Ga), Oa && U(this.matrices.model, Oa, this.matrices.model), this.matrices.build(), Na = this.matrices.result[14], 0 > Na && (Na = 0), Fa = wa ? Ga.getLOD(E(Na, wa, this.LODbias)) : Ga.getLODReference(Na), Fa && (this.status == ya.STATUS_OBJECTS && (Ya = !1, ee(this.matrices.boundary2, Fa.sphere.center, this.matrices.modelView), ja = J(this.matrices.boundary2) <= Fa.sphere.radius * Fa.sphere.radius, ja && (Ya = !0), ee(this.matrices.boundary, Fa.sphere.center, this.matrices.result), Ba = Math.abs(Fa.sphere.radius * (1 - this.matrices.boundary[2])), 1 > this.matrices.boundary[2] && Math.abs(this.matrices.boundary[0]) < 1 + Ba && Math.abs(this.matrices.boundary[1]) < 1 + Ba && (Ya = !0)), Ya && this.drawRigidPart(Ga, Fa, Ma)); return !0 } stackTransforms(Pa, Oa, wa) { for (let Na, Fa = wa; Fa && Fa != Oa.root;)Na = Oa.getConstraint(Fa), U(Pa, Na.transform, Pa), Na.offset && P(Pa, Pa, Na.offset), Fa = Oa.getParent(Fa); return !0 } drawRigidPart(Pa, Oa, wa) { if (!Oa.meshID) return !1; const Fa = this.resources.getMesh(Oa.meshID); if (!Fa) return !1; const Na = this.getVertexArray(Fa); let Ba = Oa.indexStart; this.extensions.vertexArrays.bindVertexArrayOES(Na); for (let Ma of Fa.getGroupsByReference(Oa)) this.meshGroups.has(Ma) || this.alignVertexArray(Fa, Ma, Oa, Ba), this.drawVMeshGroup(Ma, Ba, wa), Ba += Ma.indexCount; if (Pa.wireframe) return !0 } alignVertexArray(Pa, Oa, wa, Fa) { const Na = this.context; let Ba = Pa.indices.slice(Fa, Fa + Oa.indexCount), Ma = wa.vertexStart + Oa.vertexStart; for (let ja = 0; ja < Ba.length; ja++)Ba[ja] += Ma; return Na.bufferSubData(Na.ELEMENT_ARRAY_BUFFER, 2 * Fa, Ba), this.meshGroups.add(Oa), !0 } drawVMeshGroup(Pa, Oa, wa) { const Fa = this.context; let Ya, Na = this.resources.getMaterial(Pa.materialID), Ba = this.getProgram(Na.shader), Ma = 0, ja = Pa.indexCount; Fa.useProgram(Ba); let Ga = this.ambientColor, Xa = Fa.getUniformLocation(Ba, "uTexture0"); Fa.uniform1i(Xa, 0), this.status == ya.STATUS_BACKDROP && (Ga = Ta), wa && (Ga = RED), Fa.activeTexture(Fa.TEXTURE0), Fa.bindTexture(Fa.TEXTURE_2D, this.blankTexture), Ma = 1; let Ha = Fa.getUniformLocation(Ba, "uRenderMode"), Va = Fa.getUniformLocation(Ba, "uDiffuseColor"), ka = Fa.getUniformLocation(Ba, "uEmissionColor"); if (Na.diffuseTexture) { let ei = this.resources.getTexture(Na.diffuseTexture); ei && (Ya = this.getTexture(ei, Na.alpha), Ya && Fa.bindTexture(Fa.TEXTURE_2D, Ya)) } Fa.uniform3fv(ka, Na.emissionColor ? Na.emissionColor : ha), Na instanceof lt ? (Fa.blendFunc(Fa.SRC_ALPHA, Fa.ONE), Ma = 10) : Na.alpha ? Fa.blendFunc(Fa.SRC_ALPHA, Fa.ONE_MINUS_SRC_ALPHA) : Fa.blendFunc(Fa.ONE, Fa.ZERO); let Wa = Fa.getUniformLocation(Ba, "uModel"), za = Fa.getUniformLocation(Ba, "uView"), qa = Fa.getUniformLocation(Ba, "uProjection"), Ka = Fa.getUniformLocation(Ba, "uNormal"); Fa.uniformMatrix4fv(Wa, !1, this.matrices.model), Fa.uniformMatrix4fv(za, !1, this.matrices.view), Fa.uniformMatrix4fv(qa, !1, this.matrices.projection), Fa.uniformMatrix3fv(Ka, !1, this.matrices.normal); let Ja = Fa.getUniformLocation(Ba, "uAmbientColor"), Za = Fa.getUniformLocation(Ba, "uLightCount"), Qa = Fa.getUniformLocation(Ba, "uLightPosition"), $a = Fa.getUniformLocation(Ba, "uLightColor"); return Fa.uniform1i(Ha, this.mode & ya.DRAW_TEXTURES ? Ma : 0), Fa.uniform4f(Va, Na.diffuseColor[0], Na.diffuseColor[1], Na.diffuseColor[2], Na.opacity), Fa.uniform3fv(Ja, Ga), this.status == ya.STATUS_OBJECTS && (Fa.uniform1i(Za, this.mode & ya.DRAW_LIGHTING ? this.lightCount : 0), Fa.uniform3fv(Qa, this.lightPositions), Fa.uniform3fv($a, this.lightColors)), Fa.drawElements(Fa.TRIANGLES, ja, Fa.UNSIGNED_SHORT, 2 * Oa), this.drawCount++ , !0 } createRenderObject(Pa) { const Oa = new Sa; return this.objects.set(Pa, Oa), Oa } getVertexArray(Pa) { if (!(Pa instanceof Dt)) throw new TypeError("Invalid mesh data object"); if (this.vertexArrays.has(Pa)) return this.vertexArrays.get(Pa); const Oa = Oe(this.context, this.extensions.vertexArrays, Pa); return this.vertexArrays.set(Pa, Oa), Oa } deleteVertexArray(Pa) { const Oa = this.context, wa = Oa.getExtension(ga); if (!(Oa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!(Pa instanceof Dt)) throw new TypeError("Invalid mesh data object"); if (!this.vertexArrays.has(Pa)) return !1; const Fa = this.vertexArrays.get(Pa); return wa.isVertexArrayOES(Fa) && wa.deleteVertexArrayOES(Fa), this.vertexArrays.delete(Pa), !0 } getTexture(Pa, Oa = !1) { if (!(Pa instanceof nt)) throw new TypeError("Invalid texture object"); if (this.textures.has(Pa)) return this.textures.get(Pa); const wa = Ue(this.context, Pa, Oa); return this.textures.set(Pa, wa), wa } deleteTexture(Pa) { const Oa = this.context; if (!(Oa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!(Pa instanceof nt)) throw new TypeError("Invalid texture object"); if (!this.textures.has(Pa)) return !1; const wa = this.textures.get(Pa); return Oa.isTexture(wa) && Oa.deleteTexture(wa), this.textures.delete(Pa), !0 } getProgram(Pa) { if (this.programs.has(Pa)) return this.programs.get(Pa); const Oa = this.resources.getShader(Pa), wa = Le(this.context, Oa.vertex, Oa.fragment); return this.programs.set(Pa, wa), wa } deleteProgram(Pa) { const Oa = this.context; if (!(Oa instanceof WebGLRenderingContext)) throw new TypeError("Invalid rendering context object"); if (!this.programs.has(Pa)) return !1; const wa = this.programs.get(Pa); return Oa.isProgram(wa) && Oa.deleteProgram(wa), this.programs.delete(Pa), !0 } screenSpaceToPixels(Pa, Oa) { const wa = this.context, Fa = .5 * wa.drawingBufferWidth, Na = .5 * wa.drawingBufferHeight; Pa[0] = Math.round(Fa * Oa[0] + Fa), Pa[1] = Math.round(Na * Oa[1] + Na) } } ya.DRAW_STARS = 1, ya.DRAW_NEBULAE = 2, ya.DRAW_OBJECTS = 4, ya.DRAW_EFFECTS = 8, ya.DRAW_HELPERS = 16, ya.DRAW_OVERLAY = 32, ya.DRAW_TEXTURES = 64, ya.DRAW_LIGHTING = 128, ya.STATUS_UNINITIALIZED = 0, ya.STATUS_INITIALIZED = 1, ya.STATUS_STARTED = 2, ya.STATUS_BACKDROP = 3, ya.STATUS_OBJECTS = 4, ya.STATUS_OVERLAYS = 5, ya.STATUS_FINISHED = 10; class Ia { constructor() { this.result = new Float32Array(16), this.model = new Float32Array(16), this.view = new Float32Array(16), this.projection = new Float32Array(16), this.modelView = new Float32Array(16), this.normal = new Float32Array(9), this.boundary = Y(), this.boundary2 = Y(), this.boundaryRadius = Y() } perspective(Pa, Oa, wa, Fa) { return M(this.projection, Pa, Oa, wa, Fa), !0 } build() { U(this.result, this.projection, this.view), U(this.result, this.result, this.model), U(this.modelView, this.view, this.model), R(this.normal, this.modelView) } } class Ra { constructor() { this.viewport = void 0, this.bindings = { forward: 87, backward: 83, left: 65, right: 68, up: 69, down: 67 }, this.pitch = 0, this.yaw = 0, this.pitchLimit = 90, this.sensitivity = 0.05, this.movement = me(), this.movementLength = 0, this.maxLength = 300, this.interpolation = 0.675, this.action = 0, this.direction = Y(), this.rotation = ne(), this.rotationInverse = ne() } update() { return this.direction[2] = this.direction[1] = this.direction[0] = 0, 0 < this.action && (this.action & Ra.FORWARD && (this.direction[2] += 1), this.action & Ra.BACKWARD && (this.direction[2] -= 1), this.action & Ra.LEFT && (this.direction[0] += 1), this.action & Ra.RIGHT && (this.direction[0] -= 1), this.action & Ra.DOWN && (this.direction[1] += 1), this.action & Ra.UP && (this.direction[1] -= 1), Z(this.direction, this.direction)), this.target && (ge(this.rotation, this.pitch, this.yaw), this.target.rotate(this.rotation), (0 != this.direction[2] || 0 != this.direction[1] || 0 != this.direction[0]) && (le(this.rotationInverse, this.rotation), te(this.direction, this.direction, this.rotationInverse), this.target.move(this.direction))), !0 } turn(Pa = 0, Oa = 0) { return this.pitch += Pa, this.yaw += Oa, 0 > this.yaw && (this.yaw += 360), 360 <= this.yaw && (this.yaw -= 360), this.pitch < -this.pitchLimit && (this.pitch = -this.pitchLimit), this.pitch > this.pitchLimit && (this.pitch = this.pitchLimit), !0 } handleEvent(Pa) { switch (Pa.type) { case "pointerlockchange": if (!document.pointerLockElement) return Pa.currentTarget.removeEventListener(Pa.type, this), void this.releaseControl(); this.viewport = document.pointerLockElement, window.addEventListener("keydown", this, !1), window.addEventListener("keyup", this, !1), this.viewport.addEventListener("mousemove", this, !1); break; case "keydown": switch (Pa.keyCode) { case this.bindings.forward: this.action |= Ra.FORWARD; break; case this.bindings.backward: this.action |= Ra.BACKWARD; break; case this.bindings.left: this.action |= Ra.LEFT; break; case this.bindings.right: this.action |= Ra.RIGHT; break; case this.bindings.up: this.action |= Ra.UP; break; case this.bindings.down: this.action |= Ra.DOWN; }break; case "keyup": switch (Pa.keyCode) { case this.bindings.forward: this.action ^= Ra.FORWARD; break; case this.bindings.backward: this.action ^= Ra.BACKWARD; break; case this.bindings.left: this.action ^= Ra.LEFT; break; case this.bindings.right: this.action ^= Ra.RIGHT; break; case this.bindings.up: this.action ^= Ra.UP; break; case this.bindings.down: this.action ^= Ra.DOWN; }break; case "mousemove": let Oa = Math.sqrt(Pa.movementX * Pa.movementX + Pa.movementY * Pa.movementY); Oa < this.movementLength + this.maxLength ? (this.movement[0] = ce(this.movement[0], Pa.movementX, this.interpolation), this.movement[1] = ce(this.movement[1], Pa.movementY, this.interpolation), this.movementLength = Oa) : console.warn("Turn exceeding boundary:", Oa), this.turn(this.movement[1] * this.sensitivity, this.movement[0] * this.sensitivity); } } requestControl(Pa) { if (!(Pa instanceof HTMLCanvasElement)) throw new TypeError("Invalid target canvas element type"); return new Promise(Oa => { this.release = Oa, document.addEventListener("pointerlockchange", this, !1), Pa.requestPointerLock() }) } releaseControl() { return window.removeEventListener("keydown", this), window.removeEventListener("keyup", this), this.viewport instanceof HTMLElement && (this.viewport.removeEventListener("mousemove", this), this.viewport = void 0), this.release && this.release(), !0 } } Ra.FORWARD = 1, Ra.BACKWARD = 2, Ra.LEFT = 4, Ra.RIGHT = 8, Ra.UP = 16, Ra.DOWN = 32; const Da = window.requestAnimationFrame, Ca = window.cancelAnimationFrame, La = { path: new URL("/DATA/", location.origin), antialias: !1, alpha: !1 }; class Ua { constructor(Pa, Oa) { if (!(Pa instanceof HTMLCanvasElement)) throw TypeError("Invalid canvas element type"); this.settings = Object.assign(La, Oa), this.status = Ua.STATUS_STOPPED, this.loader = new Be(this.settings.path, this.settings.progress, this.settings.message), this.resources = new ia(this.loader), this.render = new ya(Pa, this.settings.antialias, this.settings.alpha), this.input = void 0, this.scene = void 0, this.nextFrame = 0, this.ticks = 0, this.previous = 0, this.delta = 0, this.elapsed = 0, this.loop = we.bind(this) } start(Pa, Oa) { return 0 < this.nextFrame && Ca(this.nextFrame), this.scene = Pa, this.input = Oa, this.elapsed = 0, this.previous = performance.now(), this.status = Ua.STATUS_STARTING, this.nextFrame = Da(this.loop, this.render.canvas), !0 } stop() { return 0 != this.nextFrame && (Ca(this.nextFrame), this.nextFrame = 0, this.status = Ua.STATUS_STOPPED, !0) } } return Ua.STATUS_STOPPED = 0, Ua.STATUS_STARTING = 1, Ua.STATUS_INPUT = 2, Ua.STATUS_SCENE = 3, Ua.STATUS_RENDER = 4, n.flcrc32 = u, n.FileLoader = Be, n.UTFReader = We, n.UTFEntry = ke, n.Resources = ia, n.TargaImage = at, n.DirectDrawSurface = it, n.Texture = nt, n.VMeshRef = At, n.VMeshGroup = Rt, n.VMeshData = Dt, n.VMeshWire = Ct, n.FixedHardpoint = Sr, n.RevoluteHardpoint = _r, n.PrismaticHardpoint = yr, n.FixedConstraint = or, n.LooseConstraint = dr, n.RevoluteConstraint = lr, n.PrismaticConstraint = ur, n.CylindricConstraint = mr, n.SphericalConstraint = cr, n.SceneObject = na, n.LightSource = oa, n.RigidObject = la, n.SolarObject = class extends la { constructor(Pa) { super(Pa), this.health = 100, this.destructible = !1 } }, n.PerspectiveCameraObject = da, n.SpaceScene = class { constructor(Pa) { this.title = Pa, this.color = new Float32Array(3), this.nebulae = void 0, this.stars = void 0, this.ambient = new Float32Array(3), this.objects = new Map, this.lights = new Map, this.zones = new Map, this.camera = new da, this.elapsed = 0 } *getLights() { for (let Pa of this.lights.entries()) yield Pa } *getObjects() { for (let Pa of this.objects.entries()) yield Pa } update(Pa) { this.elapsed += Pa, this.camera && this.camera.update(Pa); for (let Oa of this.objects.values()) Oa.update(Pa) } }, n.ShowRoomScene = class { constructor(Pa) { this.color = new Float32Array(3), this.target = new la(Pa), this.ambient = new Float32Array(3), this.camera = new da, this.lights = new Map, this.objects = new Map, this.elapsed = 0, this.ambient.fill(0.125), this.objects.set("ShowRoomSubject", this.target), this.camera.position[2] = -Pa.getRadius(); let Oa = new oa; this.lights.set("ShowRoomLight", Oa), Oa.position[0] = 4e3, Oa.position[1] = 4e3, Oa.color.fill(1) } *getLights() { for (let Pa of this.lights.entries()) yield Pa } *getObjects() { yield this.target } update(Pa) { this.elapsed += Pa, oe(this.target.rotation, this.target.rotation, 0.25 * Pa / 1e3) } }, n.Render = ya, n.SelectionControl = class { constructor() { this.viewport = void 0, this.position = me(), this.size = 0 } update() { } handleEvent(Pa) { switch (Pa.type) { case "mousemove": this.size = Math.max(this.viewport.width, this.viewport.height), this.position[0] = Pa.offsetX / (.5 * this.viewport.width) - 1, this.position[1] = 1 - Pa.offsetY / (.5 * this.viewport.height); } } requestControl(Pa) { return Pa.addEventListener("mousemove", this, !1), this.viewport = Pa, !0 } releaseControl() { return !!viewport && (this.viewport.removeEventListener("mousemove", this), this.size = 0, this.viewport = void 0, !0) } }, n.FirstPersonControl = Ra, n.Glancer = Ua, n }({});